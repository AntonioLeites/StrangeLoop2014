Strangeloop 2014
September 19, 2014 -- Day 2.

"Programming Should Eat Itself"

Presenter: Nada Amin

Live captioning by Norma Miller, whitecoatcaptioning.com.

ALEX:  Good morning, everyone.  Am I on?  OK.  It's great to see everyone back.  Unfortunately today is the last day of Strangeloop.  So aww, I know, but we'll do it again.  It's OK.  So it will be back Sept 24 to 26 next year, so same venues and all that sort of thing, so I look forward to seeing you all again next year.
>>
AUDIENCE MEMBER:  Woo!
>> Don't clap yet, we've got another whole day.  I did want to mention a quick few things.  If you are parking at Union Station, make sure to pick up a parking voucher down at the registration desk.  If you signed up for the Cardinals tickets today, if you prepaid for the Cardinals tickets, please be sure to stop by the registration desk sometime today to pick up your ticket and there are some tickets available, as well, if you want to purchase them.  They're $20, and you can just pay at the reg desk, and so that's all the housekeeping I have today.  I'm looking forward to having a great day today.  I'm very excited to introduce our first keynote speaker for the day, and I've known Nada for a couple of years now and I've seen her speak several times, and she always -- I'm always very impressed, and she's one of the smartest people I know, and she has shown this sort of chameleon ability to work across industry and academia and Scala world and the Clojure world and Scheme world and probably other worlds that I'm not aware of.  So I'm very excited to introduce Nada Amin.
     NADA AMIN:  Hello, everyone.  Is the mic on?
     All right.  Thank you very much, Alex, it's an honor and pleasure to be here, and so Alex asked me to try to bridge academia and industry, and I thought that one way to do this would be to talk about programming to understand programming.  So kind of in a more reflective way.  And so this is why my title is "Programming Should Eat Itself," and I want to start with this quote from SICP, which is the evaluator that determines the meaning of expressions in a programming language is just another program....  So here you have this hint that while a program can have another program as data, and I wanted to take this further by referring to the literature on towers of interpreters and reflective towers of interpreters.  So turtles all the way down.
>> So at the top here where the elephants are, we have the user level, and then you can think of each turtle as a meta level.
>> And just to make it -- we can just represent it this way, so the user level is actually the meta level zero, and then we have the first meta level, the second meta level, the third meta level and we can keep going down.
>> So it seems like at some point we need to stop, and the question is, can we -- once we take this idea and not try to be meta circular in the sense that the user level semantics and the meta level semantics are using the same language, but also be reflective in the sense that each level above, so for example the meta level 0 is defined semantically by the meta Level 1 and this one is defined by the meta level 2, so so you can change each level independently.  All right, so this is a bit abstract and I guess it's time for some code.  And for this demo I will be using the reflective language Black, which is in scheme and it's coding a paper by Kenichi Asai and others, and I will have references at the end.  All right, so here I have a normal scheme prompt and just for those who are not familiar with Scheme basically you just -- this is just a shell so I can evaluate 1, and the way it works is the when you have a parentheses, the usual thing is you have an application and the first position is the procedure function amend the other positions are the operant.  So I can do this.  I can also define functions.  So let's say ...  And then just say this:  And I can also just anonymously call functions and use them.  
     All right.  So this is pretty basic.  Let's play with Black now, so I'm loading the Black system and now I'm going to Black around here we see that we've started at this new prompt, which says 0 and 1.  So the second number is really just like the number for the current query, and the first one is at which level we're at.  So now we're at the meta level 0, which is the user level.  So like before, I can define inc and then do inc 2.  But now let's say I do a typo, and now I've moved up to the meta level.  So you see this one here.  And here it's also a normal Scheme prompt, so I can do this, and now in order to go back to the lower level, I just use this continuation.  And since the error happened when evaluating this increment function, we expect to have some value that would match here, so I can just use any function here.
>> And so this will return 2.  Because basically it's kind of as I had resumed computation here and with this lambda xx, I get 2.  All right, so let's go to the meta level again by doing the error again.  And now another thing I can do here is I actually have access to a base evaluator.  So base eval is a procedure here.  And this is one way that I can, from the meta level, inspect what is going on at the user level.  So I can say base eval inc, and then I also have to provide some environment and some continuation, which I would expect.  So before doing this example, let me just do a simpler one, where I can say base eval 1 for example and use an empty environment and just like the identity continuation, so this returns 1 at this level and now if I do this, I actually get the definition of inc as data from the lower level.  So now I can again here jump to the lower level by doing old-cont.  OK.  So this with was equivalent to basically continuing with the inc function at the error here.  All right, so now we've seen a little bit how to go one level up by triggering an error, but we can also just go up explicitly by using this exit, which kind of means like go down in this turtle chain.  
     So if I do exit hello, I'm back to the first level with the value hello and I can keep going up.  And now I've loaded a new level, which is the meta level 2.  And again, I can go down step by step.  All right, and there's another thing we can do, which is go basically this EM function, which is exec at meta level.  But I'll just use em because it's easier, so I can say EM1, for example, and this is executed at the meta level, but we stay at the level 0.  
     So that's not so interesting, but I could do EM say define foo1, and now this foo is now defined at level 0, but now I've bumped up to Level 1 and it's defined here.  And so if I continue with it.  All right, so that's -- that's the basic thing and one thing that's interesting is with this EM, we can also do that if we want.  And that would be defined at the second level, but not say the first level.  All right, so now let's look at what we can do with the system.  Just to give an idea of what's going on, we have this base eval interpreter, which is kind of in this typical meta circular style except that it has a level of indirection to be able to build this tower.  So one thing we can do is -- let's say we want to define -- yeah, so let's say we want to define just a simple instrumentation function.  So it's actually a little bit -- the way this system is set up, using mutation a lot, but the gist of the idea is that you can, at the meta level, -- so let's go up, at this level, I can say, OK, define original eval application to be the eval application and now I can modify it to do something else.  
     So let's say I do set eval application, so that when the first argument -- yeah, so let me just write it somewhere so that it's easier.  So I can do this, and each of these things, like the base eval, they all almost take this expression, this environment, and this continuation.  So here for example, I can say, when I have -- when my expression is -- yeah, so already we know it's an application, so we know it's a pair.  And we can say when the first element of the expression, let's say, is a my, then here I want to do something special, which is to be defined, and otherwise, I just want to call the original eval application with exp and cont as before, so now I have to do here, and say I'm just returning my and ignoring all the arguments.  So now I can define this at the meta level.  
     And if I go back, and now let's make sure things are still working so this should still work.  But now if I do my 2, I just get my back.  Well, this is interesting, because let's say I have a completely looping function, so let's say this is just calling itself, so this is an infinite loop.  I'm back, yeah, so here I made a mistake, I just returned my instead of using the continuation, so I ended up on the wrong level, so what I wanted to do here was call the continuation to go back to the original level.  
     So let's go evaluate this again and go back.  OK.  All right, so that's fine, now I'm back at the original level, and so now if I do this loop function, which I definitely don't want to call and let me just -- well, I guess I don't want to call it -- but maybe I can just for the -- yeah, so it's looping and now I'm kind of -- I've messed up my buffer, but anyway, so yes, let's kill it.
     Restart.  OK, so I'm back here, and now I'm actually going to load directly this -- let me put this in a file like live Black for example and I am directly going to load this from the meta level. OK, so I can do this live Black, all right, so let's define this loop function again, right, and now if I do my loop that actually still works, because I've kind of padded this my thing as a special prompt that when I'm doing the application, I'm not even looking at the argument here.  I'm just looking at the first expression.  So just to -- for people who don't use Scheme, basically this just returns the my, and that's all I'm testing.  OK, so what interesting things we can do by changing the meta level?
     So one something is instrumentation and using the same pattern, I can kind of say, OK, well, if you have this instrumentation special form, then do this.  And this is a function that I define normally, so the thing is, you can think of it as macros, but instead of macros being just the syntactic rewriting where you have to worry also about hygiene and variable naming, here we are just using a normal function at the meta level to do something special, like a macro.
     So just to illustrate this, yeah, just to illustrate this instrumentation function, I -- I've defined these church numerals and things, because -- OK, this is going strange.
[laughter]
     Because I, yeah, I will actually go back to the Strangeloop, yeah, I just loaded the strange version of that file, so it was completely messed up.  OK.  So now if I load this file, at level 0, I've basically defined all these -- all this data structure as number, so I guess some of you might be familiar with, say, the church numeral, where you define a number by a function basically you define the number N as something that takes a function and applies it N times to some argument, right?  So zero is just saying, well, we take this function and this argument and we just return it and 1 is saying we take this function and this argument and we apply it once, we can apply it 2, we can define successor, etc.  So one thing that's been tricky historically is to define predecessor, and here I have two versions of it, one which is using extra data structures like pairs and another one which is a more direct version.
    And so I can try it out by doing, say, predecessor of C2.  And then I'm converting it to a number so I can see it and I get 1, or I can do the add version.  Now, one thing we can do with the system is really just instrumentation as something that we've added at the meta level.  So let me load at this meta level this instrumentation Black.  And now I have access to this instrumentation function, which takes any expression, and it calculates, say, the number of applications that happen to evaluate this.  And here we have lots of application, because basically this encoding, the only thing you can do is create functions and apply them.  And so we can compare the two versions and see that one has like -- one is this alternative version is much more efficient and like just to show how we can take this further, we can actually also decide to instrument everything, so I did instrumentation for atlam and bar, so I can load this version, and now when I instrument this, I get all the information I wanted.  OK.
>> Well, actually so what's interesting here is that at the meta level, you can do what you want and treat it as data.  So one thing that I thought was kind of cool is let me actually rename this buffer to Black so I can start a Scheme buffer, as well.
>> And in Scheme, I can define -- all right, so here I have another fancy -- some fancy function, and I'm not going to explain it in detail, but it's basically known as the TABA pattern, which is from Olivier Danvy et al. paper and TABA stands for, I'll leave the reference later.  And TABA stands for there and back again.  So the idea is let's say you want to define OK, Scheme has reverse?  Does it have zip?  
     I guess it doesn't have zip.  Let's say if I have zip somewhere.  One of the riddles, for example, is let's say you have zip of 1, 2, 3, and a, b, c, so you do that, and now the riddle is that you actually want to do this version with the reverse here with n recursive calls, so it's kind of tricky to think about this, because in some sense when you traverse this list you want to do it one way and then when you traverse this one, you want to do it the other way, so the TABA trick is actually quite clever and I encourage you to think a little bit about how you would do it, but one thing you can do is this idea that when you're going down the stack you're recursing on this list, and when you're going back up this stack, you're unwinding this list in the reverse order.  
     So that seems very abstract but in Scheme if I define these traces here and here you can see how it works so the recursive calls, I can work down the first list and when I'm going back up, I have these two things here, so this first part and the second part, and I'm kind of building the result as I go back up, by popping these things in the right way.  The idea is because, yeah, it's -- you're kind of using the language stack to create this pattern.  So I thought what would be interesting is to play a little bit in Black and see if we can get a representation of this stack.
     And so let's see.  So I've implemented several versions of it, and I guess let's look at the second one.
     So the idea here is that I -- I'm also adding these things to -- I'm adding this app hook as you've seen before so that TABA is a special form and then here for every time that these calls that are monitored by TABA, I'm actually adding things to build up the stack and create a data representation of the stack.
>> So let's play with this a bit.  Whoops, OK, I needed to define -- so see now I've jumped like very high on the thing, but I guess it's going to -- yup, so I'm back to 0 and I needed actually to import the utilities file.  OK, so now I have load TABA theme and let me also load the stack here.  OK.  So now what I can do is when I should load the convolution file, but here I will remove the trace defines, because and so now I will say TABA and walk and this and this and than I can just call my function normally.  1, 2, 3, a, b, c OK?
     OK, it's loading in the other buffer.  So let's see.  All right, good.  So now if I do this theme, I get this strange result out, because I was getting the result and the stack, but let me see results in stack in this and now the second argument should be the stack.  And OK, it's hard to read this way, but this is really just some con cells, and I have this function to present it nicely.  So now I get this -- OK, I did ...  Whoops, that's weird.  OK.  Well, I did the -- let me do this version which I think is, because the stack was tested at the meta level, so there's some strange thing going on, but let me just do this version here, which would directly print the stack.  All right.  And now I can do ... so basically I get the stack representation and you can see here that -- OK, you start this way and you're working down and then you're going back up, and this was easy to print, because actually I had this -- I created my structure so I had this information at once and this one at once.  OK.  So how are we doing on time?  
    Yeah, so 10 more minutes, so -- well, or a bit more.  Let's go back to the slides.  All right, so I mean I haven't answered fully why you would want to do this, and I'll get back to this, but first, also why not?  Yeah, OK.  And then so Dan Friedman who has been working on this for many years, has kind of taken this exponential backup approach to not working on it so much and the reason is it's made my head hurt.
[laughter]
>> I know, it's kind of like this cat chasing its tail and you know, that's kind of what academics we do sometimes, right?  We're like trying to understand some things in terms of itself and we keep doing this and I don't know, it's a bit strange, but it's also fun and it's kind of good.  So in terms of references, here are some of the papers where you can learn more about this.  I thought this was something cool to show, because say this is the paper actually the from 96 which has the code, and then recently, ASAI also had a paper in GPCE where he does this also kind of tower of interpreters, and the idea with meta OCaml, you can also do some special things so that you can maximize the quote.
>> So I thought would end off I would just kind of sketch a little bit how this works from an implementation point of view.  Actually, while I read K's paper, I actually and as I went through, I did an implementation of the paper and to me this is one of the most fun ways to read a paper, just go through it and implement it as you understand it.  And the thing is I actually tried to put this to Scheme and it was really painful because I was getting these procedures, like these errors and I really didn't know where things went wrong and the reason is that actually the way this works is pretty complicated and it helps to have a type system.  Let me just show you the Scheme version which doesn't work so you can get the idea of why it's hard.  So I did a small Black one, but I just had a hard time actually getting some things but basically you start with a base eval and this is just like a normal interpreter, but you use these meta things to just be able to tie the loop in the tower if you want.  And the thing that makes it complicated, actually, is that the way it works is that you can shift up and down the levels and you carry these meta continuation, as well.  And the thing that is complicated is you have to know, OK, which kind of function am I dealing with?  Is it a primitive function, is it a lifted function and so on and in the OCaml version, things become clearer.  So what you see here is the types help you out.  
     So instead of representing things just as Scheme lists, you actually have values that are typed and you can see, OK, I either have a number, a symbol or some sort of structure.  And I can have a primitive function are with just this for user defined function or I can have the eval function which is actually the tricky one, right, because this one is really tricky in Scheme because you have these multiple parameters and it's easy to miss one step and to make it even more complicated this meta continuation function is itself this -- if you wanted to sort of infinite stream of things, so the way to look at it is meta continuation is infinite stream of some of pairs -- of it's an infinite stream of state.  And each level has a state, so each state represents the -- if you want to represent the registers of a level.  
     And so what you have here is the way he we're representing it is the first thing we have an environment, and then we have a current continuation and then we have a stream of those.  So this is like for Level 1, Level 2, etc, and we can keep going up as much as we want but the end of the tail is lazy, so we only build levels as we need them.
>> And this other stuff was mostly to play with with combining between, but we don't need to understand it here.  So now let me give you an example of a function.  So here is how you would define eval var, and here you see in OCamL, I'm specifically looking at apply cont,s and it's an applied function.  So if I look at apply cont, I can actually look at its type, I think.  Yeah.  
     OK, yeah, so actually here, you see that this one is quite general, because it's shifting up, but in general I've put -- I've put the thing, so let's just look at a more interesting example.  So when I'm evaluating a list, what I need to do is actually -- let's say I have a list of expressions.  Yeah, right, and to evaluate this list what I need to do is say, call the base evaluator on -- if it's nil, then I just return nil, otherwise I call the base evaluator and I recursively return the list.  And so this is the part where in Scheme I completely lost track of where I needed to do the lifting or not, but fortunately in OCamL it's easier thanks to the type system.
>> OK, so I think it's kind of a bit early but I'm happy to open it to questions here and also request for things you'd like to see:
[applause] any questions?
>>
AUDIENCE MEMBER:  [inaudible]
>> Add types to your ob language?  Yeah yeah, that makes sense.  So, yeah.  Yeah, one thing I didn't get into at all is also the kind of the third part of the duality if you wants, so here we were talking about -- SOs basically we were talking about program as data and data as programs.  The title of the talk itself, programming should eat itself was inspired by work in type theory.  Type theory should eat itself, and homo tope type theory, etc., should also eat itself, and the idea is can you kind of define the types?  Can you use your theory to define your theory within it and how far can you go with this?  So it's kind of a dual aspect, but yes, I think in terms of the bugging, adding types to the object language would also be helpful, and like another thing I want to explore is with this new paper, the GPCE paper, it's actually using meta OCamL which is a generating framework, so even though you have a tower, you can collapse some user function to lower-level efficient code, but when you were doing this collapsing, you were also losing the semantics of the tower, and so one thing I would like to explore is maybe using the generative framework in Scala, which is type-driven, maybe we can do this sort of interpreter to compiler transformation automatically and then also collapse the tower with the semantics and so just a shout-out to TIKROMPF who's presenting some degenerative work in Scala this afternoon.  Any other questions?
AUDIENCE MEMBER:  [inaudible]
>> Yes, so that's a good question and I think in some sense with this system, you could implement f expressions within it, and I think for the Black system as it's defined here, it's kind of hard coding all these things, but you could imagine just having one more layer of indirection, so that f expressions could be easy to implement.  But just to actually I started doing that.  So the idea is that -- so here I had to do a lot of code, because the system was not really -- the base system was not really done so that it would be easy to add, but the idea is that you -- when you -- when you add the special form, which is f expression and you could use it as a lambda, right, so you do f expression x and f expression xy, and that's kind of like f expression xyx, so here I would have to do something like meta level x, right?  And so I would need to add the special form for f expression, and then which is kind of what I was doing here, I'm just adding this expression tag like we did before, but then the other thing I need to do is actually change the applied function.  When you evaluate an f expression, so that it -- so that when you see this as a value instead of lambda xyx, so the way it would represent this in the system is in addition here you would have an environment, and here I would have the same, so I would also have some environment here.  And then I would -- I need to change the application so that it doesn't eagerly evaluate all the arguments.  So the idea here is that when I'm doing the application, I can actually say, well, just evaluate it without preevaluating the arguments, so just to make it clear, if you have lambda x plus x1, and foo bar, like in Scheme, what will happen is if you think about it as evaluating this -- evaluating this and evaluating this, and then this -- and then basically -- well, actually, you don't need the and let's say foo is defined to be 2, then the result of this evaluation is some sort of closure, right, closure representing plus x1 and foo is just 2 and this is where you have the application part.  Now, for f expressions what you do instead is that you would say -- you would basically say, if I did fx -- if I did this, I would just do -- I would just want to apply it as fx closure if you want, and have one here and not even evaluate the 2, so I would just be passing it -- I would just be passing it this as a symbol instead of as the result of evaluation.
>> And actually, another nice paper is called -- is by it's this one, Open Extensible Composition Modules, which shows just by having a layer of indirection, so just by having a level of indirection here, I can -- I can write my eval and apply in such a generic way that f expression would hold true.  I think historically what happened was that f expression, where it was decided that there were -- it cost too much of a penancy for performance, because you would basically never know when you would optimize the arguments or not.  The problem is you would have something here, and arg1, arg2, arg3, until you have this you don't know whether you have the optimization of these arguments.  Any other questions?
>>
AUDIENCE MEMBER:  [inaudible]
>> Yes, I think that's also a better idea.  One thing that I found difficult in this Black system is that basically you're mutating everything on the fly, and so it's -- I mean at some point when you get into a weird state, you just have to restart and it's not good, but I think by refining the store, you could play some really cool tricks with -- yeah, just basically being able to undo as many sometimes as you want and things like this.  So I haven't played with that so far yet.  But I mean I guess my hope with this talk is just to get people interested in playing with these things for fun and also as a way to kind of get some of the ideas from academia, like just playing with some of the ideas from academia, so the way I usually do, and really the most fun I've had with papers is really using this approach where I start through the paper and go really complete and just try to play with the system and also do my own expressions.  All right, so any other questions?
>> All right, oh, yeah?
>>
AUDIENCE MEMBER:  How is this different than Scope?  Is it really granular?
>>
>> So, it's --
>>
AUDIENCE MEMBER:  Maybe I don't understand.
>> How is it different from Scope, so Scope in which sense?
>> Yeah, so, well, let's see, I mean the -- so in some sense, what you can do is when you're adding these things at the meta level, you can also really Scope things lexically, right, and you can also use like dynamic scope, as well, but I think what you're saying is how is this different from just redefining, say instead of adding this at the meta level, I could use trace define and get the same effect, right?  Yeah, so yeah, I mean I think in terms of a practical application, I think it doesn't make sense to use this.  It makes more sense as a kind of -- kind of just this way of like, well, instead of programming to to it's programming to understand the context of something.  And the fact that you have all these levels is kind of a bit -- it's actually -- I'm still trying to think about other things we could do, so of course, talking with William Bird, we were saying, well, OK what if you had a logic level at a meta level, right, so you could have some kind of meta logic for your user level or things like this.  So I see what you mean in saying OK, OK, you can solve some of the same issues in terms of tracings without using this meta level approach, but this is more about kind of going back to the picture like, just defining your semantics in terms of other semantics that is similar.  All right.  Anything else?  All right, thank you very much.
[break]
