Strangeloop 2014.

"The Challenges and Benefits of a Functional Reactive Frontend"

Presenter: Ian Davis.

Live Captioning by Norma Miller, whitecoatcaptioning.com

[Norma's note: I think Ian started without me.]


...  significant difference between simple and easy.  Ease means something is near at hand or easily accept ... it's important to note that ease does not necessarily imply simplicity, in fact, without a lot of work, ease can often lead to something that's very complex.  So what is this talk actually going to be about?  Well, the goal is to assemble a flexible toolbox that sort of simplifies the traditional complexities of web development.  At Prismatic we have a pretty heavy emphasis on design and we're still trying to figure our core product.  So we need something that's flexible, that lets us build quickly iterate fast.  We want to see what technologies are out there that we can use to apply a lot of the same principles to web development.  So I'm going to talk about what the traditional complexities in Javascript are, and where they come from and then we're going to talk about why ClojureScript is a good solution for solving these complexities and gives us a lot of these good basic tools to help out web development and then I'm going to talk about React a Javascript framework by Facebook and how its functional approach to DOM manipulation is really better than anything else out there if you want to do functional declarative UI development and then I'm going to talk about Om, which gives us some really nice benefits of the marriage of these two technologies and finally I'm going towrope wrap up by taking about the practical challenges and benefits that we get from this architecture.  As far as I know we're one of the large ... so let's start with what problems Javascript has.  The first book that most web developers are typically handed is Javascript, the good parts and that's because the good parts of Javascript are actually quite small subset of the language as a whole.  How many of you have ever participated in a hackathon before?
>> And now, keep your hand raised or raise your hand again if you were really proud of the quality of your code at the end of hackathon.
>> Javascript was made in ten days in May and Brendan Eich shipped it far too, too soon.  You get the double equals that automatically typecast everything to a string because that makes a lot of sense if you're trying to determine if things are equal and when you are combine that with the original design goals that they wanted a language for nonJava programmers, which could be written directly in HTML, something that designers, beginners and amateurs could learn by the yard.  What this really boils down to is that Javascript was designed to be easy and accessible.  I think this easiness is what's made it one of the most ubiquitous platforms out there.  A lot of designers I know can code in Javascript and do HTML in CSS but the number of designers who can write an iOS app or an android app, I can basically count on one hand.  But if you think back to our quote, simple is hard and making something that is both simple and easy is harder and Eich didn't do that so we're left with a language that's easy and quite complicated.  The most common example people use is this sort of preliminaryicity[?] Global which in this function here I'm trying to define a local variable, but if I accidentally forget the var declaration which is very easy to do, suddenly I'm mutating this variable in the global above that.  
     If you don't have a global that's OK, it will go ahead and create one for you, and even when you know about this pitfall it's very easy to forget and Java doesn't throw you any errors to tell you you might have made a mistake.  And it gets even harder when you consider hoisting.  Even though this is defined without the var statement at the top, if someone else defines it with a var statement, that will automatically get hoisted to the top, meaning it's impossible to tell at a first glance whether I'm dealing with a local or a global variable.  
     But the problem here isn't really the global hoisting.  It's the fact that you have this global mutable state.  And this is problem even on local levels.  When I pass in foo, I don't really know what that function is doing to it.  It could come back out anything else.  And if you do have a bug in your code, tracking it down is a nightmare, because you know, it could have been mutated by any one of these functions, there's no way to easily track where these changes are being made.  
     And I think that with Javascript, you really need something that's going to warn you of these pitfalls that's going to make sure that you don't make the easy mistakes and for a lot of people the solution is JS link, which is a good way to prevent a lot of the more silly things that Javascript does, but things like mutable state, JS link doesn't really correct for, because that's an opinion that the language has that making things easier with mutable state is a good idea and we sort of disagree which is why we chose Clojure script as our language of choice.  It's not just cosmetic differences.  ClojureScript actually adds real value to our development process.  It creates a very simple set of basic tools, and with the power of macros, it allows it to be really, really easily extendible so we can write our own tools to build upon the language itself.
>> So we look lex co-scoping this is how you do it in Javascript, and it looks structurally to the let binding in ClojureScript and that's because ClojureScript basically takes the best practices that you should otherwise be doing in Javascript and it sort of enforces and codifies them in the code and there's no way to accidentally fuck up this let binding because mutable refs are so much different than normal immutable values that you really, really know when you're changing something.  And you sort of the same reason that we like a good type system or a good sest suite, ClojureScript provides these guardrails that prevents us from using the bad parts of Javascript and falling into these pit falls and this is I think another example of this go in Javascript that's sort of incidentally complex.  There's four different -- there's four sort of slightly different ways that this gets bound and it gets magically bound behind the scenes and once you've been programming for a long time, you learn to memorize these four different ways, but it's really not necessary for there to be four different ways.  In ClojureScript we only have one method of sort of binding this and we're not even binding it, it's explicitly passed as the first argument to protocol functions.  And so I think Javascript is getting a lot better and so I want to talk a little bit about.  There are some bad things too, and they still have to leave a lot of these pitfalls in there for backwards compatibility but this is one of those, and this is the yield operator, which allows you to create in this case an infinite sequence of Fibonacci numbers, and it gives you back a generator that you sort of call next on to get next value, and in ClojureScript we sort of already have the ability to build up a lazy sequence like this very easily.  
     I think it's a little bit cleaner to have, you know, a long lazy sequence that you can use sequence processing functions on it's still immutable, you don't have this stateful object that you have to keep calling the next method on but I think more importantly, I can ship this code right now, I think true of a lot of good things that with ECMAscript 6.  ClojureScript already has this functionality right now.  And something like  transducers which was just announced we could put into our code and ship right now without having to wait for browser manufacturers to actually integrate it into their run time because it compiles down to a very basic set of Javascript that's already supported on all platforms.
>> And it also lets us to build our own tools really easily.  And in this case, I want to talk about, you know, this nested Json map.  We've got the data that we actually want to access is three levels deep.  And we've got this function that you know, we want to pull out the data, transform it in some way, but we also want to assert in a safe way that all of the values we have actually exist, and that they confirm to the types that we expect them to.  And this is the only real business logic of this code, the rest of it is just sort of annotation and data extraction, and so for us at Prismatic we've taken our two popular open source libraries, Plumber and Schema, and we made them work in ClojureScript as well as Clojure, so this gives us the nice ability to do the sort of map extraction in the actual destructuring of arguments, and if you look down at the last three arguments, we have these type annotations of string, number, and boolean and Schema will throw errors if it doesn't conform to our expected type and so that gives us a lot more safety and this is all because ClojureScript provides the ability to sort of reshape the language to our specific use cases.  You know, there's a lot of people in the Clojure community who are don't necessarily like these type annotation, but for us they're a huge benefit and for us we get to pick and choose which parts are most useful to us and which parts we want to extend further functionality with.  And we can do it without giving up any of the existing Javascript ecosystem.  In this case, calculating the length of a tweet, I don't know if any of you tried to do this, it's actually kind of complicated because you have to determine what's actually a URL and there are a lot of edge cases with URL detection, but Twitter provides a really, really nice library for doing a lot of this stuff in Javascript.  And so for us, we can use and import that Javascript library very easily and so that sort of 99% of the code we write is still in ClojureScript and still gives us all the benefits of that but when we do need to use an existing Javascript library, the interop is actually very simple.
>> Now I want to talk about DOM manipulation.  The DOM and HTML was initially designed as a way to mark up static content that's coming down from the server and then slowly over time people wanted a little bit of interaction here and there and now we're in a stage where you know, you want these large interactive web apps, but you have this imperative API for DOM interaction that's not really good for any of these web apps.  I think if any of us were to design a system purely in code no one would think that the best way to manage your data is to have a large globally accessible mutable object that everything pounds on at once, but that's what we have to do with a DOM.  
     So I want to talk a little bit about Prismatic and how our product works is we have a variety of feeds that are about a specific topic in this case urban exploration and the feed is a collection of stories that are tagged with specific topics.  So since this is the urban exploration feed, everything is about urban exploration, but the top article is about Japan and the second article is about water and a user can follow a topic to indicate that they want more content about that particular topic.  
     And so when the user actually follows a topic, the underlying data change is actually very, very simple.  We're just toggling a Boolean somewhere in our data model that says you're now following urban exploration but that change has to be updated multiple places in the DOM and when you're doing this manually it's really hard to remember all of the differences and detect all of the differences here and you're really just inviting errors by not creating a system that manages this for you.  It's sort of human nature to be forgetful, and any time it's easy to forget something there's going to be a bug and the more things you have to remember, the more forgetful you're going to be.  And nobody really does this manually anymore, everyone is sort of using a lot of MVC frameworks, but I'm arguing that a lot of these MVC frameworks aren't actually any easier.  All it does is it takes your DOM mutation and it shifts all of that mutable code into your Javascript, and the there's this tight binding between sort of the tight coupling between templates and your data that really doesn't suggest that they should be in separate places.
>> And when you do actually separate them out, you have enough -- you need enough control flow in your templating language that you ever end up inventing a whole second domain-specific language just to do templating, when you already have a fully featured language that you're doing the rest of your development in.
>> And so we chose React as opposed to, you know, ang ember or one of these, because it completely extracts away the DOM so we never actually interact with the DOM ourselves, we just interact with React components and they propagate all of the necessary changes for us.
>> And how a particular React component works is it's a functional mapping.  It has a render function which is a functional mapping from our data to virtual DOM of what it would look like if that were the data and so we get all of the power and expressivity of ClojureScript or Javascript when we're writing these render functions and you get this sort of fully declarative, completely referentially transparent way of describing what your DOM should look like and it encapsulates all of the dynamic interactions and all of the dynamic state in a single function so it's really, really easy to reason about exactly what the DOM is going to look like, given what your data looks like.  And this actually makes it a lot easier to test, because you do of this functional mapping from data to DOM.  And I mentioned this before, but it's worth repeating again we're outputting virtual DOM here, not actual real DOM and you can still compose these functions together, these components together, in a way that basically builds up a hierarchy, similar to the way you would do a DOM, and how this now is when a user follows an interest, they follow the travel interest in this case and that propagates back to the data and then React recomputes the entire virtual DOM which sounds really inefficient, but it's far more inefficient to touch the real DOM and so doing all of this in code is actually quite fast.  And then React actually does a dip on the current virtual DOM and the real DOM and only actually writes the minimal change set.  So this essentially takes away all of the complexity that we would have had to do before, of thinking about exactly where and how we need to update the DOM.  All we do is we write this component hierarchy once and then our actual interactions are just changing our application state and everything else immediately propagates from there.
>> As sort of an added benefit, event handlers become almost trivial to write.  You get a lot of complexity from sort of the overhead of event handlers, you have to make sure that you're not listening more than once, that you don't accidentally set it up twice, the node that you're trying to listen to actually exists right now or that there's no reference loops between the DOM and your Javascript.  And really when you're writing them in line on components that get blown away and updated as needed you don't have to worry about any of this overhead anymore and it really lets you focus on the core problem, which is changing your application state, not worrying about how to change and mutate the DOM.  So Om combines React and ClojureScript in a really nice way that sort of adds a lot of nice benefits for us.  The first is that we centralize our entire app state, so that all of our event handlers and all of our client server communications all go to one giant mutable ref and this allows us to sort of deduplicate all of our client-side state and put everything in a single canonical place.  Makes it much easier to reason about the direct mapping to a full application state to a full DOM rendering which gives us some nice serialization benefits, but you know, at first glance that sounds really bad, because having a single giant mutable reference means that you know we can't easily decompose into subcomponents, because how atoms work in ClojureScript is you sort of swap the entire value all at once and this is trivial to do with immutable data because you can just pass down a smaller piece of your data and keep a pointer to it and let the trial mutate it.
>> Take this large application and boil it down to just the actual part that we care about.  It provides a window, basically, into the managed ref as a whole that we can treat just like an atom, and when we update this atom, it immediately propagates that change back to the application state as a whole.
>> And so this allows us to sort of decomplect all of our components from the actual application structure, while maintaining the benefits of immutable data, so if we look at this code here, we have in Prismatic the notion of a paginated list, which is a items, a next URL to fetch more items and a remaining count and this is the way that we take sort of long sequences, like our scrolling feeds, and break them up into reasonable chunks, and because React handles all of the rerendering whenever our data changes, if we want to generate a full feed, this is all of the code we need.  It takes into one of these paginated lists.  It doesn't care what kind of list it is, or what the objects are in that list, it just fetches more from the server, using the sort of same core abstraction and paginates everything in.
>> And sort of the ability to fill out an entire feed of information without ever actually thinking about the DOM means that our concerns really are separated in a way that they wouldn't be in another architecture.
>> So now I want to talk about sort of what this, you know, having this large mutable object actually gives us some pretty neat performance benefits when using Om, because React has this method called should component update which gets called every time it's about to recompute a particular virtual DOM from your component.  And it defaults to true, which is why the entire tree got rerendered last time.  And it devolves to true because it's actually really complicated to tell if your reference to a piece of immutable data is different or not.  You essentially have to walk the entire data structure on both sides to determine equality, but in this particular case, we can do a simple fast reference equality check on our immutable data and that allows us to sort of prune parts of the tree that we don't actually need to recompute.  So the only parts that really get recomputed here are the parts that have actually changed.  And afterwards, React still does the same sort of minimal change set to the DOM so really all we're doing is we're eliminating all of this intermediate work that we would otherwise do that's really not necessary.
>> And so I want to talk about the last section, which is sort of is it ready for production, which is the most common question I get when I'm trying to talk about this with people, and I think the answer is mostly yes.  It works really, really great for us in production, but it sort of really depends on your team and I think for most people in this crowd, the answer is probably yes, too.
>> Our architecture is a lot simpler than it used to be.  Before we switched over, the sort of complexity had almost paralyzed our development, because everything was so intertwined that whenever we tried to make a change, we would have to sort refactor parts of our code base just to make small changes.  And I don't know if this is true for other people, but I get a lot of joy out of using such a well designed abstraction and for me the sort of -- I'm basically spending my entire day writing pure functions, either you know, data processing functions in ClojureScript or these nice, you know, render functions that take in data and directly output to DOM.  There's less finnickiness than I used to have to deal with.  And there's also a lot less context than I think there was before.  In our case, our back end and our front end now use the same language, so any engineer is comfortable with sort of anything in our code base, and right now, the only way to achieve that on the web is to use note on the back end and a sort of you know, machine learning and natural language processing company that's not really an option for us.  And it's also everything is sort of fully functional and referentially transparent, so even an engineer who doesn't understand our system can come in and very, very easily see how a piece of data is being transformed into the DOM because it's sort of all laid out for them in a single function.
>> So sort of anyone can jump in and immediately feel comfortable making changes, which actually is really useful for us, because we're fairly small product team, but we have a lot of back-end engineers who want product changes in the app.  It's also extremely expressive.  One of my coworkers wrote 2048, the sort of popular game, in about 200 lines.  And David Nolan in his post introducing this wrote that to do MVC app in about 260, and this expressiveness scales to larger code bases, as well.  When we implemented this system for the first time, we went from sort of 26,000 lines of code to a little over 5,000, which is a pretty big reduction for us.
>> And it's because it's so much easier to reason about and all the context you need is in one place, you get a lot fewer bugs than I think we used to have.
>> Now, these are sort of only the small ones that come from these inconsistencies.  Every once in a while you still get, you know, you still have typos and they're usually a lot harder to track down when you do get them, but overall, I think the sort of volume of bugs decreases.
>> And when you actually compare it to a similar backbone architecture, it ends up being two to four times faster for -- to do MVC benchmarks and this wasn't even really a priority for us.  We're not at the sort of performance optimization stage, but it is a really, really nice benefit.  And I think all of these things -- besides just, you know, application speed, all of these things together combine to make, you know, a much faster development speed, and there's no real tangible proof I can give to that, besides our anecdotal experience, but you know, we are building things faster hand we are and we're making drastic redesigns and experimenting with new products in a way that we couldn't have done under our old architecture and there are definitely some caveats that make it not necessarily right for everyone.  I think it requires a fundamentally different way of thinking about UI development.  In the same way that when you first go from sort of an imperative object-oriented language to something that's more functional, you have to sort of switch your thinking.  When you move from traditional DOM manipulation to React, you have to go through a similar mental shift and it's not a big mental leap, but you definitely do have to reason and structure your application much differently than you would under another system.
>> And you sort of have to figure things out on your own, you have to figure out how to structure things differently and you know, ClojureScript, Om, and React are fairly new compared to angular and Javascript so when you run into a problem it's not going to be easy to go to Google or stack overflow and find the answer to it.  There's not nearly as much of an ecosystem or as many developers around these technologies yet but if you're sort of willing to be adventurous they do have a lot of performance benefits.  And for us, because we have our entire team on the language, we don't have any sort of down sides of people speaking different languages, which can frequently be a problem in larger organizations.  And I think the sort of -- I want to give a -- so I'm sort of wrapping up here.  I want to give a huge thanks to the Cognitect guys and the React team because they really, you know, made these frameworks or libraries, I should say, and sort of trailblazed in a way that allowed us to develop such a clean architecture.  I think that it's really easy to try these things out.  ClojureScript may be a little bit harder, but you know, immutable data there are a lot of good Javascript libraries out there for it and React itself we specifically first tried it on a settings page without, you know, rearchitecting our whole app and Facebook only uses it in for small parts of the interaction on the Facebook app, and so, you know, if you're thinking about this, I really do encourage you to try it in a small piece, first, see how you like it and then if you're convinced, sort of move to a larger implementation.
>>
>> And then the last thing I want to do is sort of give a thanks to everyone at Prismatic where I work.  I think we implemented Om about a month after it was first open sourced so we were definitely in the early development phase and they also helped me refine a lot of this talk and listened to me talk at them over and over and over again, so yeah, I wanted to just give a huge thanks.  Any questions?
AUDIENCE MEMBER:  [inaudible]
>> Yes and no.  We basically we tried it on an experimental feature branch, so we tried it for an independent project that wasn't our main app.  And then slowly that sort of independent project evolved into a redesign of our main app and then we switched everything over, so there was definitely a period where we were sort of supporting both Javascript and where we were supporting two different apps.  No, not within our app, we had two branches, we had the old version running and we would go and fix bugs on it but all of our new feature development was happening in ClojureScript, but that lasted for only a couple of months.
>>
AUDIENCE MEMBER:  [inaudible]
>> Well, so it's first off it's not actually global.  It's a single app state but it's passed in to the root component and then decomposed from there.  I think the reason we wanted to decompose it is because like in this case, you know, writing an interest label that has the entire application state to it is really complecting a lot of things together.  That means every single component in the tree has to know about the full state of the app and I think for us because we were already using ClojureScript, the idea of using one giant immutable ref just sort of came naturally from that.
AUDIENCE MEMBER:  [inaudible]
>> No, this is how Om works out of the box, yeah, so this wasn't our innovation, this came from David Nolan.  Anything else?
>>
AUDIENCE MEMBER:  [inaudible]
>> So the question is, you have inputs coming from user interaction and you have inputs coming from the server, and did that cause any problems for us?  And I think the really nice thing about using a managed ref in Clojure here is that you know, you get, Javascript isn't multi-threaded but you get a lot of the same benefits as if you were doing multi-threading with these atomic updates, so all -- you just have to make sure that you're -- because you're going from sort of old state to new state, it's almost impossible for the data to get out of synch and so sort of the worst thing that can happen is, you know, a user like double clicks a button and we've updated something locally and then a server request comes back and then sort of overwrites their change but the minute that change gets overwritten, it's going to be reflected in the UI by React and so the user knows what the underlying state is in a really transparent way which allows them to sort of undo that.  I think it avoids, because of this sort of managed full-state transfer, it avoids getting different places out of synch with each other, which is usually the problem there.  Anyone else?  Bueller?  Cool ... ...
[break]

