Strangeloop 2014 

"React:  RESTful UI Rendering"

Presenter: Pete Hunt
Live Captioning by Norma Miller, whitecoatcaptioning.com.


     PETE HUNT:  Hey, everybody.  How's it going?  So I got like two hours of sleep last night and I was really looking forward to getting Dunkin' Donuts this morning, because I'm original will I from Massachusetts and we don't have it out in the bay area and then I realized there wasn't Dunkin' Donuts around here.  So the primary energy wasn't there so I'm just going to fake it.  You guys cool with that?  So my name is Pete, and I'm an engineering manager on the Instagram team at Facebook.  And my team owns pretty much all you see on..  -- so we have a lot of tools for big brands to manage their accounts, a lot of tools for advertisers and a lot of kind of back-office tools for our community, as well.  So I'm also a major contributor to a Javascript library called React which we open sourced last year in May.  It was kind of a different way of looking at building users interfaces in the browser.  I got a master's in focus on distributed systems a couple of years ago, and I'm going to try to pull some of that knowledge into this talk but it's been a couple of years since I've studied that so don't hold it against me.  But first a little bit about React.  This is the way that we build all new user interfaces at Facebook moving forward so this isn't just one team coming up with the way to build user interface or somebody's pet project that we open sourced.  This is a big engineering strategic decision that we made as a company for how we're going to build these new interfaces, and so some projects we've used it on are our graph search product, our news feed, liking and commenting.  Our chat product on the web, the buddy list and the chat windowo.  We use it for our insites products, as well.  Depending on your browser.  Also works on mobile pretty well, too, we upload photos on mobile web through React and we drive our primary app navigation on the web is also on React, as well, and Instagram.com is one giant React component so that was kind of the first giant full-page app that we launched, but I'm not here to really sell you on using a Javascript library or anything like that.  The thing is we learned a lot of hard generalizable lessons when we were building React and when when we were building applications with React.  And one thing I noticed is that the industry in other parts of the industry has learned similar lessons, so I'd like to share with you the lessons in a we learned, compare those to lessons learned in other parts of the industry and hopefully this will be a good set of guiding principles for how to build systems.  So I'm going to talk about the evolution of distributed systems.  So in 2014, it's easier to build a distributed system than it's ever been before and the way that I go and build distributed systems is I shout across the room to my friend Rick Branson so I think is here, he's at Strangeloop and he's an infrastructure engineer on Instagram, and I asked Rick, how do I solve this problem?  And he usually gives me an answer that looks kind of like that.
>> That was from Strangeloop, I think, two years ago, or three years ago, wow.
>> So it kind of in the late '80s, maybe even before that, message passing was kind of de facto way that you built a distributed system, so one of the most popular message passing libraries was standardized in the early '90s, it's called MPI.  And we're starting to see kind of a renaissance of this model, too, with things like communicating sequential processes in Clojure, it's kind of the same model.  You have this underlying network that's noisy and you have processing in different machines and they need to communicate with each other.  So the obvious:  Mess.  This.  The kind of underlying programming model is very simple, it's passing messages between two processes or multiple processes, and this is great, this kind of is in a usable abstraction, but the problem is that it's really low level so when I sit down and I want to build an application and I think think about how I'm going to model it, I don't want to think in terms of point to point messaging, because my real application has state that evolves over time and when you're kind of building an application with messages that are passed from point to point, it's very difficult to model these states over time and get the state on one box, synchronized with the state on the other box.  Reason for that is the abstraction is really low level.  It's almost like Embler[?] for distributed systems.
>> So a couple of years go by and we start to see the emergence of these distributed object systems.  They have names like CORBA, RMI, SOAP, DCOM.  The higher level abstraction for expressing these concepts in a distributed system.
>> And the basic idea was, we take object oriented programming which is kind of popularized by small talk and worked great for single machine applications.  People were having a lot of success being object oriented programs.  And so you can create an object on one machine, pass a reference to it to another machine, that reference could get passed around the entire system.  So when you're able to pass these remote object references around, you get a lot of implicit messages between lots of modes.  So when you call a message you're not sure if it's local or if it's on a machine on the same rack or across the world.  So you get a lot of implicit messaging that you're not sure is really going on.  So individual nodes in your system might have to talk to lots and lots of other nodes, because there's lots of unconstrained communication.  And so these types of architectures are generally pretty unpredictable, so you ever need to answer a couple of questions with a distributed system.  What's going over the wire?  When is a computation running?  Where is the computation running?  Like on which machine?  How do you handle the failure is cas so on a single machine system latency is you know for a function call is kind of pretty flat whereas in a distributed system it can be very variable.
>> And also, failure cases are a lot more important to think about in a distributed system.  And so kind of the traditional single machine object-oriented approach doesn't really work when you want to glue it wholesale into a distributed system.
>> And a lot of these problems boil down to the fact that multistep, multidirectional messaging makes the system slow, fragile and unpredictable.  So if I have two machines that need to do a lot of coordination between each other, it's going to be slow.  If one message may lead to lots of other cascading messages, that can make the system fragile or unpredictable, as well, because you need to hold a lot of that information in your head in order to understand what it's doing.  The way.  They're really leaky abstraction, the network leaks through and leaky abstractions are often worse than no abstraction at all so I would actually prefer to use message passing than a contributed system.
>> And it doesn't have these problems or the problems of multidirectional data flow and cascading side effects are at least explicit in message passing.
>> So then we kind of started to see the rise of rest after that.  And this is a paper by Roy Fielding, and it's an interesting approach.  So he wanted to build, for distributed systems from the ground up, so he's not taking an existing paradigm and gluing it to an existing environment and the way he expresses this idea is he gives you a set of constraints and he says if you apply these constraints to your system when you're designing it, you will get these certain properties of your system and the idea is you apply these constraints, you fall into the pit of success.
>> So what are these properties that we want to get with a REST system?  Well, we want performance, and performance is kind of a meaningless term, but we really mean through-put, user-perceived performance, so if we poll our users, they feel like the app is fast and efficiency, it doesn't cost us a ton of money to run this system.
>> Scalability is another one.  How many nodes can we add into this existing system, and what does that curve look like?   Simplicity, can one person predict how the system will behave.  So if you're dealing with a catastrophic failure can you load enough information into your brain fast enough to solve it before Twitter explodes with complaints about how bad your site is?  Modifiability, so you start the system out with one set of requirements but that never stays static, you always have changing requirements and how easy is it to adapt the system to these changing requirements without breaking these other properties?  Visibility, how explicit is the communication between nodes?  This situation where you have a distributed object oriented system and these kind of implicit messages between nodes is very difficult to debug, both from a correctness and performance standpoint.  And finally, reliability, which does the damn thing work?
>> So we want to get these properties and rest gives us a play book for getting these properties and they give us a set of constraints and the first constraint is client server and what I think he means by this is separating the concerns that the client deals with, are completely different -- or be concerns that the server kind of thinks about are completely kind of separate from the ones that the client thinks about.  So for example, the one that they use in the paper is the client deals with rendering the user interface in the traditional kind of HTML app and the server deals with data storage so there's no overlap of concerns there and it's always one client talking to a server.
>> Statelessness:  Now, every system has state in it, it's pretty impossible to get away from that.  The state has to live somewhere.  But the idea here is that the server doesn't hold onto any state that's living on the client.  So for every request that the client makes to the server, even though the server might have state for itself, it doesn't hold onto the client's state.          
     Cachability.  So by default you want your interactions to be cachable and you want to explicitly opt out of that.  Now, the messages that you use for most operations is get which is how you want to read data and when you want to make a write.  You say post.  And that opts you out of caching.
>> Layering is another.  Clients can't tell if they're directly connect the to the underlying app server or to they're talking to some middleman.  So when you go to Facebook.com, you go through several layers of caching and proxies and things like that and the browser doesn't even know that it's talking to all those servers.  It's just that these protocol supports layering.
>> And finally is uniform interface, and there's a whole section in the paper about this.  But the gist of it -- that I took away from it, anyway -- is that data or resources are identified by a name called a URI and the representation you use to read that data should be very similar, if not identical to the one that you use to write it so in your canonical to-do app you post.  It will give you back some Jason in a new schema.
>> I use the same kind of scheme in a Json serialization of it.
>> Let's look at how the evolution of distributed systems compares to the evolution of UI development.
>> So if you look at how we built UIs in the web, kind of at the beginning when we first started doing it, you kind of started to think of PHP spaghetti so there's no separation of the concerns that render user interface with the parts of your code that do data storage and the parts ever your code that expand your events.  And I wasn't around with this.  He tells me that early 80s code was similar to this.  There wasn't really a play book for dividing up the concerns of your application.  And then MVC came around and this was supposed to be the seed to the ad hoc abstracter.  Let's pull that management code out of our rendering code so we can render that data in multiple different ways.  And then we have this controller thing that will glue it all together, so you basically have a controller that observes change events in a model and a view and it mutates both of them.  It is one popular flavor of MVC.  There's lots of other popular flavors, but when I say MVC in this talk it's going be to based on the idea of fine-grain observer tracking.  
     Now, when you're observing lots of change events, you kind of get into a similar system that you have with a distributed object system.  In that you have a lot of implicit observation events that you're depending on.  So one piece of data in your model might depend on another piece of data in your model, and so when the dependency changes you have to trigger a change event for this other piece of data, as well.  And that can cascade through your system.  
     Also, there's hidden dependency events.  When we were building in Facebook, we found that if events fired in a different order, they would converge to different states and that made things really difficult to predict.
>> And so some of the things we're thinking about when we're building a browser is we need to know what DOM operations are happening and when the DOM operations and computation events are happening, as well.  If you write to read from the DOM and write to the DOM again, you can get into this kind of really bad performance situation.  So you really need to manage those reads and writes.  So this is very similar to the problems that we face in distributed systems.  Instead of having this slow losing network, we have this sort of slow, crusty DOM that we're reading to and writing from.  So we found that multistep, multidirectional callbacks make the system slow, fragile, and unpredictable.  
     So we built this system called React.  I'm going to walk you through a code sample just to have kind of set some context around of the discussion, but this isn't a tutorial, and I'm not trying to teach you how to build an app with this.  The basic idea with React is it is a JavaScript library and you create components.  That's the only thing that you do.  If you've got interface development on the Apple platform, if you're coming an angular platform, JavaScript, that kind of thing, these are directives.  But to create a component by saying react.create class.  And then there's a render method and the render method is called whenever the data changes that the data depends on and it's returning a description of what it wants its user interface to look like, so we like to call this a virtual DOM.  These don't touch the browser IPAs at all.  I would like you to create an DIV please and.  And React under the hood actually creates and manages these DOM nodes for you.  You'll notice that I'm reading some is values from this .state in there.  We make it explicit that you know, here is how we create our initial state.  When we handle one event, here's an explicit state transition.  So when the user starts typing something into this text field, we will update our current state of the text field to reflect what the user has typed, and this is, you know, if you think about those REST principles, right?  We also have a submission handler, as well.
>> And so what I found, kind of when building applications, is nine times out of ten when I have a bug that isn't a layout bug it has to do with some bad state transition in my app or the way that I've modeled state.  So remember, we have these constraints that REST gives us to help us fall into the pit of success.  Let's see how this code sample compares.  So the first one was client server, where we want to separate our display logic from our DOM in manipulation in our application.
     We're returning descriptions of what we want to happen and React manages that.  So you're only concerned with what do I render not how do I render it.  Statelessness is another restful property.  So the client doesn't need to think about the state of the DOM, so even though this component is stateful, it's not worrying about the state of its client or its server, which is the key property in REST.  And the state that we do have is very, very explicit.  
     Cachability, this is another tenet from REST.  The way that React works is that we return that description of the DOM.  These DIV and H3s and those types of things.  But we actually upstate a.  What React does is it keeps a copy of the previous tree of descriptors and then called render again and it walks those trees, DIFs them and then:  But that's generally very perform ant, but sometimes that DIF can actually take a long time.  And you can benefit from caching.  So if we had this to do item component and we rendered thousands of these into the browser.  We can actually tell React to cache the last call of render and skip kind of subsequent calls based on certain criteria, so we can add a method called should component update, which is basically our cache invalidator and the default is true.  You can override this and say, Hey, React, when the item text that I'm receiving is the same as the last item text, I'm not going to change my render method, so cache this result.  And we see order of magnitude speedups.  
     Layering is another important tenet of REST and we've kind of embraced that in React, as well.  So rendering user defined in native components is identical.  So for example, in our render method here, we render a native form tag.  And this is the form tag that you know and love from browser development.  But right above it we actually render a to do list component, as well, and this is defined inside of our project.  This isn't built into the browser.
     So the way that we invoke to do lists and form, there's a different name, but the way that we do it is exactly the same.  Actually under the hood we swap out out our form component and add more:
    And finally uniform interface is the last kind of REST constraint.  When you want to create or modify a component in React you use the exact same interface.  You just put in a different descriptor.  This ...
     So we get initial state which says it's been clicked zero times.  When we receive the click event, we update that state.  But what's important to note here is that we don't have separate initial render and update phases.  The way that you express your initial render is this render method.  And the way that you express updates is also this render method in the exact same way.  And the return values are the same except for that count.
>> This is an example of a uniform interface.
>> We also have a lot of RESTful properties inside of implementation, as well.
>> So I'm going to oversimplify the implementation of React a little bit, but the basic idea is that we have the browser up here in the upper left corner and the browser sends native browser events to their React event system, and even in 2014, browser events aren't standardized completely.  There's little quirks to each of them.  So it will actually normalize these events to the W3 spec.  So it will look for those event lists in their names and bubble it correctly and it will dispatch a synthetic event to user code like I've shown you today.  Then this user code might called set state and it might rerender itself.  And it emits a descriptor.  That goes into our DIF algorithm, and then sends imperative DOM operations to the browser.
>>
>> So one of the RESTful constraints that we've applied here is client server.  These all look like client server interactions.  The arrows are all pointing in one direction, and React DIF knows nothing about the state of the user code.  It simply looks at those descriptors that it's getting passed to it.  Just like React event doesn't care about the state of the browser.  It just looks at the event it's receiving.  The user code doesn't care about the state of the event system.  It only cares about that synthetic event at this point in time.
>> And finally, React DIF actually does care about the state of the browser so this is kind of an abstraction around the browser.  We're wrapping this stateful browser that we don't control.
>> And so you know, this goes into the statelessness property of rest, as well.
>> Cachability, so it's not quite caching, but we have these messages being passed throughout various components in our system and we can buffer them at any stage.  So the ClojureScript wrapper around react which is called Om, out of the box will buffer these events.  So then you only send one descriptor rather than a descriptor for every event you receive.  And we can buffer our DOM operation queue.
>> And it's a really great way to debug kind of performance and correctness issues.
>> Layering is another principle of rest REST that we have he' applied to the back end.  I have a box here for the browser and I've been using that as a stand-in for the word DOM.  So the data structures that you manipulate that are serialized to HTML and basically represent the WH3 spec.  There's no reason this couldn't be a canvas or we couldn't render SVG.  You can actually swap in any kind of back there and it will still work as long as it adheres to these basic messaging protocol.  So we took all these principles into account and we think we've come up with a system that's performant, scalable, simple, modifiable, visible, and reliable.  Because it's RESTful.
>> And React isn't the only system to stumble across these fundamental principles.  I could make the argument that eunuchs pipes are RESTful, MEM cache is RESTful, many game applications are RESTful.  And Facebook's new iOS is also RESTful, and a little inspired by React, I have to say.  There's one noticeable omission from this list and that's the upcoming web components standard.  I don't think that web components and the ecosystem around themes including polymer, I don't think they have the respect for these properties.  But that's a whole other talk.
>> So I'd like you to try applying the principles of rest into your problem domain.  We applied these principles to ui development.  It ended up working pretty well.  And these are just general good software development principles so you might just fall into the pit of success.  This is the link to our repo if you're actually interested in doing web development in the browser in the same way.  My name is Pete, and thanks a lot for listening to me.
[applause]
>> .  [inaudible] Does React come with the ability to deal with SVG or canvas out of the box or --
>> The question is, does React have out of the box applicability for canvas and SPG.  The answer is yes.  We have a library called React art where which actually sits in the box and what you do is end up creating these things called art components rather than tags that represent divs and spans and the underlying art library will look at the environment and say I should render to canvas or SVG.  The we've had kind of OK, but not great support for that, historically, but it's getting better all the time.
>> Yeah?
>>   [inaudible] 
     React manages all the DOM manipulation for you.  So the way that it handles it, is it ewes up these state transitions into a queue, and it flushes that at a time that makes sense, so you can actually plug in this flushing strategy and it will coalesce everything in that queue and it will only rerender in DIF once, so that pattern converges to an existing state.  So any kind of library that you have on the page is manipulating the DOM we can't make those guarantees and that's one of React solves for us is unconstrained manipulation of this constrained layer really sucks, and it's hard to think about.  ... ... ... ...
>>
AUDIENCE MEMBER:  [inaudible]
>> The question is, what's the next frontier in front-end development.  This is cool.
[laughter]
>> So I have found that -- to give you a little bit of background, like I spend most of my day working on products, so I found that a sadly large portion of my day is spent figuring out how to lay out the boxes on screen and I'm actually pretty good at CSS and understanding layouts and flexbox is OK.  I've had a lot of fun playing with constraint layout systems, so there are a big performance questions with layout systems.  But you can.  Say I want to glue this NAV bar to the left-hand side of my content area beings which is exactly the way people think about these things.  They don't think in terms of flow left and things likes that so I think it if that proofs to be performant, and I think Apple is -- I think that's a pretty cool new frontier.  The other big thing that I spend a lot of time on is data fetching.  How do I shuttle a lot this data from the server to the client.  If I have enough time, that's one thing.  How -- if I'm on a mobile device, I might be offline, that I think is it a huge area of active research that we're working on at Facebook and I know there's a bunch of startups that are also doing that.
>>
AUDIENCE MEMBER:  [inaudible]
>> What is the relationship between React and web components?  Do we see React becoming a standard API, rather than a library?  If I had my way, we would prove out this concept as being, like, unbelievably better than the other ways of expressing UI logic and we've kind of done that at Facebook and we're doing that at the community at large, and if that trend continues, I'd like to see maybe iOS 10's composition starting to look more like React, our API has been pretty stable for a couple of years, but we do have breaking changes coming in 0.12 and if we start making a standardization component, that.  So I don't think we have plans for standardizing, but we're team players, so we'd be happy to participate in those discussions.
AUDIENCE MEMBER:  [inaudible]
>> So the question is, why did I say web components aren't RESTful?  The whole idea of -- the reason why we built React is because the DOM is stateful, and when you make a change to the DOM it sticks around for a long time and when you have that state duplicated in the DOM.  So that state that's in the DOM has to exist in the UI code somewhere and one of the things about REST is the server doesn't know anything about the state of the client.  And that's duplicated state and that scale, that really sucks.  So what web components are doing, is they're just building more functionality out of the box.  Now there's a bunch of standards that are layering on top called model-driven views, which is basically meant to synchronize your application in the state of the DOM through traditional data binding techniques and we're kind of offended by that, too, because that has the cascading changes problem so when you're observing changes in real time and you're calling call backs that may trigger cascading changes, we found that that would blow up our call stacks and make it really difficult to debugs, so we're really hoping it doesn't get built into the browser.  Does that answer your question?
AUDIENCE MEMBER:  [inaudible]
>>
>> So the question is, we've seen a lot of success with immutable data closures, are we using that at:  The answer is yes.  We recently open sourced a immutable JS which is kind of similar to Mori.
>> Yeah, I would say that starting in 2012, immutability and some of these ideas in functional programming really started taking hold on Facebook.  So even the way we read data in PHP is done in an immutable style.  And the fastest way to do it is to use immutable data structures, so it's pretty much a done deal at Facebook at this point.  We're not using ClojureScript, but you know, we take what we can get, right?
>>
>> Any other questions?
>>
>> Cool, thanks a lot, guys.
[break]
