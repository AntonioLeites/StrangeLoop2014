
Strangeloop 2014

"Type Systems - The Good, Bad and Ugly"

Presenters: Amanda Laucher and Paul Snively.

Live Captioning by Norma Miller, whitecoatcaptioning.com.


>> Hi, welcome.
>> Howdy, everybody.   I'm Amanda.
>> I'm Paul.
>>
>> Hi ... ...
>>
>> We're having technical difficulties already.
>> OK.  OK, so we're going to get started talking about type systems, the good, the bad and the ugly.  So what makes a type system great?
>> What is it we're trying to accomplish?  So the first thing we're trying to point out is we're trying to write better software, I think everybody here has that common goal and Amanda and I, especially when you were here two years ago when we presented, we sort of stacked the deck in our favor a little bit by saying we like type systems, but we like good type systems and not all type systems are awesome and to get back to the goal, what's the goal, the goal is to make the right thing the easy thing.
>> Yeah, I really wanted to be centered at the intersection of easy street and lazy way.  I want to want to get the most bang for my buck.  I want the easy thing to be the right thing.  And if I'm working too hard to make something work or to prove that it's correct, then I'm doing it wrong.  So a great type system really is the cross between easy and lazy.
>> But not all type systems are great.
>> We want to tell you exactly what we mean by that.  How tired are you of hearing Java sucks, I hate Java.  Everybody says it all the time and it's really hard to understand what they mean.  Do they understand what type systems really are?  It's really hard to tell from that statement because everybody has been saying it so long.
>> So what's again going on with the goal.  There's a great quote, the goal is to make illegal states unrepresentable.
>> And really that implies the fact that you had to know what the states can be in the first place.  What is an illegal state, making sure that you've done the reasoning, you've figured out the logic to determine what are those illegal states, and then have the ability to make them unrepresentable.
>> Yup.  So none of this is original thought the.  I don't think I've had an original thought in my entire life.  This is all about type theory, it is.  And there's a huge amount of formal literature out there.  What we have here is called the lambda cube.  The big beware sign basically means you know, here there be math.  We're not going to actually talk much about all of that, but that is the foundation for what we will talk about.  We're basically trying to do a TLDR on type theory.
>> So before we even get started with any of that, I've been going around the conference, preconference, talking to people and saying what do you think about type systems?  What are your opinions?  Where are we even starting from, to make sure we're on the right track with this conversation and all I keep hearing is I don't get the types of bugs that a type system will present and really what that says to me is that this person lacks the knowledge to understand what a type system can do for them so there's so much learning to do and it would be easy for me to say, you lack knowledge, go read but this stuff ant documented in any digestible way.
>> Also they may have experienced with a type system but it may be one of the ones on our bad list or on our ugly list, we don't know.
>> You'll either have issues if your issue is a type system issue and you're running in a dynamic language, you're going to crash, right?  Not necessarily.  You're doing it wrong that way.  If you think that crashing is the only problem, then you're doing it wrong and you don't fully understand what a type system can give you.
>> This is Paul's quote.
>> Oh, yes, yeah.  Right, and I have to look more closely at it.  Did I say that?  Yeah.  This is literally what I told Amanda, if the only type systems I was familiar with were Java, C, C++s or  , I'd be a Ruby programmer, too.
>> This is exactly why we have so many crappy, crappy crappy Ruby developers that are now crappy crappy crappy Clojure developers.  Certainly you can be an expert programmer, you can be amazing at what you're doing and use those languages, but I tend to think that if you're not thinking about the types, then there's a good chance you're not a great developer.
>> And actually, Anton man Stratton is fond of laying on lambda the ultimate that you have types in your head, so even if you are programming in a dynamically type language, you are in fact thinking about the same things that those of us who work in statically type languages are thinking about.
>> I met this really awesome woman last night who made the statement that if you fabric softener you can be a programmer because some logic in your head that made you buy fabric softener.
>> So all type systems are not created equal.  So really up front, this is not intended to be controversial.  Everything we're going to tell you is a fact.  That wasn't a joke.
>> So it's not controversial unless of course you have some passion for any of these languages and then you may be a little bit annoyed with us.
>> Or a lot annoyed with us.
>> They're still facts.
>> To be fair, we will offer some facts and we will offer some opinions about those facts.  But I do want to put stake in the ground and that is that not everything is opinion.
>> So what does it mean for a type system to be good?  What makes a type system good?  Right, and for you 80 movies fans, especially bad 80 movies, here's Howard, so what has he got?  He's got a plate of curry.  So this is all about the Curry-Howard isomorphism, and that's what we're shooting for when we talk about a good type system and for those of you who aren't familiar with it, the fundamental thing that it claims is that a type is a theorem, and the implementation of a function of that type is the proof of that theory.
>> Stop.
>> Did you guys hear what he just said?  Did you process that?  That is so powerful.  You don't think like that, I don't think like that, nobody thinks like that.  But if you sat back and think exactly what he just said, that is so important, that is so important to the way we write our code.  If you're not thinking about theorems and proofs, totally makes sense but you better have come up with the logic in advance of writing that in order to know what you're doing.
>> Yeah, it's perfectly valid for it to be an intuition, you don't have to be sitting oh, I have this property of my software and I have to the proof for it.  Some of us do that on purpose for at least part of our code if not all of our code, but it's OK if you don't think that way at all.
>> The function type, the function type is logical implication.  The arrow, I don't know how many people are familiar with the symbology of symbolic logic.  There's a one-line arrow means functioning take type to another type.  Under the Curry-Howard isomorphism they're the same thing.  So when you write a function, you can, and arguably should, think in terms of my type is actually a property that I want to express a proof of.  The proof will be a function and what I've got here is a couple of scholar signatures, one of which expresses the notion of for all.  It's universal quantification from logic.  You want to say that something is true for ever value of some type.  It's ridiculously easy this is a good example of how you can express formal logic concepts in at least one statically.
>> it has to have the ability to express some types.  This is essentially saying earlier we talked about making illegal states unrepresentable.  If you've thought about all of the inputs and outputs for your function you can create some types that actually allow you to explicitly say I can only accept this type.
>> Or that type.
>> Yeah.  So my favorite example, the simplest example I can think of for this is errors as opposed to legal values, so with some types, you have typically an either type that expresses the fact that you've got some type that is only going to be -- the value is only going to be of that type when an error has occurred and then another type that expresses the fact that there will be a value of this type if there was not a failure and that makes properly constructing code that handles failure cases in a compositional way where you're taking these building blocks and just assembling them together much easier.
>> And of course having some types is awesome, and we'll go around talking about type systems for the rest of the conference but you need to understand there's more important things than just the type system.  You also have to have language features that help you use your type system.  You need to have the ability to quickly concisely express what do I do differently in the case that it is X or Y?
>>
>> Yeah, without some types and pattern matching you're probably using the visitor pattern and emulating some types with class hierarchies and all that kind of stuff and we all know how painful getting the visitor class right can be and having toes hierarchies can be.
>> Paul likes to say that this is like sushi, until you've had it, you might not think it sounds very cool, but the moment you've had it, you want more.
>> You may not know you want it until you've had it.
>> So and then another thing that you need in a great type system is product types.  And most languages now get this, right?  We need records and objects and tuples.  How hard is it to get to that?
>> And do you have product types just by themselves without any of the baggage that tends to come along with the way product types are expressed popular languages.
>> And we've talked about something else that's really important, another language feature that's really important is currying, the ability to do partial application on these things, understanding what you want to be able to be partially applied and what you want to make not possible.
>> What are your tools for decomposing if a product type is a collection of some thing of multiple other types, how do you take partial views of that structure.  Language features outside the type system have something to say about that.
>> And then dependent types, dependent types is like the final holy grail thing, you've probably been hearing about them quite a lot, with Idris, and maybe with Scala, as well.
>> Yeah, in fact last year there was a presentation of a nice comparison of Scala and Idris, dependent types now and in the future, I think was the title and immediately after that, Brian McKenna is presenting on Idris, highly recommend checking that out.  We'll talk more about dependent types as we go.
>> This is just quick syntax where you're checking the size of a vector, you're saying the size of a vector, plus the size of another vector equals the size of the output.
>> This is getting ahead of ourselves a little bit in terms of we're going to be talking about syntax, because that's such an important thing about nontype system related qualities, but if you see the app signature here, it seems like it shouldn't be my more complicated than that, if you have a vector of size N and a vector of M, then it shouldn't be any harder than saying N plus M, where you want that to be part of the type.  That is an expression, but it's not checked at run time.  This code will not compile if you try to append a vector of size 3 and 2 in a code that needs a vector of size 6.
>> So this is a very concise overused example that in the small makes no difference.  Like you're not going to write this.  If this is your only code you're not going to write that because you don't care, but the syntax is so simple that when you do put this in your code and you make it part of a bigger picture it does make it easy to reason out later and it gives you safety that you don't get otherwise.
>> Again we're fans of compile time safety.  Yeah, parametric polymorphism.  Boy, hopefully at this point almost not worth talking about, right?  Because we all know Java got generics and C ++ got templates back in the mid 90.
>> Go.  Away.
>>
>> So the question really is what are you getting for free?  If you're not getting anything for free, then why are you doing it in the first place and type systems give you that, parametric polymorphism seems like it should be default at this point but it is hard to implement, so you can't just say go away.  It's hard to implement.  They may be released before they should have.
>> I think the Java and C++   experience was designing a language without parametric polymorphism and then adding it later on a language that wasn't intended to support it is brutally difficult so I'm waiting for the announcement from the Go team that yup, we figured out just like Java and C++   that we needed parametric polymorphism, ouch.  Ad hoc polymorphism is a nightmare.  A complete nightmare.
>> So we also feel like it's really important for a type system to be extensible and I'll use the pharm example here where C sharp has the ability to use asynch.  Whereas F sharp has the ability to make computational expressions where you can write your own asynch, if you have the same tools that the designer of the language had, you are so much more powerful.
>> Yeah, and here we have to offer a hat tip to a couple of the dynamically typed language communities, the small talk and lisp communities have insisted since time immemorial no.
>> So OK, we're just getting to the bad.  And you guys have an intuition about what's bad about a type system, right?  You all hate writing Java.  Maybe not.  Many of us do that for a living.  However, you have this intuition, we want to give you a framework to determine what's good and what's bad.
>> Right, so what's bad is mostly -- oops, too much black.
>> Ooh.  Yeah, we're suffering from a bad type system.
>> Back in the game.  Stringily typed programming.
>> So this is something that we all see, Paul and I were talking about and he's like oh, exists in the boundaries of programming, right, when you're doing IO, you have tons of strings, right?  And that's really where you want to be a little bit safer in most cases but I have a gripe that this isn't just at the boundaries, this is all about code, any time I'm reading someone else's code, they're passing strings around.  It's like wait a minute, you have a type system and you're not using it.
>> Yeah and we just talked about this before starting here, I think sometimes people who work even in good statically type languages are embarrassed to just say type whatever equals string or type whatever equals NT.  In other words, to use type aliases to model yeah, at one time it's a string or one time it's an NT.  But to help the compiler out by saying this particular type of string really belongs in this domain, this particular type of NT really plongs in that domain.
>> So huge pet peeve is this new culture that TDD is dead and static type checking is not required.  I would like to assert if you have a service level agreement based on your code, you are being unethical by thinking both of these things.
>> I don't even see how you can believe them at the same time, personally, but OK.  Yeah.  I don't know about anybody else, but the majority of my career has been in e-commerce, which basically means writing a bunch of code that shuffle around other people's money and I do agree with the assertion that there is at least part of your code, that if it goes wrong, a bunch much other people's money falls on the floor, you do actually have an ethical obligation to avoid that and type systems can help you -- good type systems can help you void that.
>> Bad type systems can help you void it.  It's just a nightmare to do it.
>> So we already talked about type aliases and how they're important.  However, so languages can either be nominally typed or structurally typed.  Meaning that I can have a function that will accept either X or Y in this instance, if it's structural.
>> Yeah, based on its shape, yeah.  The only consistently structural type system I know of is of camels.
>> Static duck typing.  So if a data structure has, you know, X number of fields of and a function expects a structure of that shape, you know, X, Y, and Z, whatever, then anything with 245 shape will go through, if it quacks like a duck, walks like a duck, the problem, as Amanda pointed out earlier when we were talking is that it is possible to get false positives that way.  It is possible to get data that goes through that the behavior isn't exactly what you want.
>> It is.  In most cases this still adds benefit.
>> So really the key to a bad type system is lacking connection between logic and your code.  And in some language designers, you can tell when you look at what they give you the ability to do, they didn't really understand anything about logic and code being equal.
>> Yeah, yeah, it's difficult or impossible to express.  And/or not at the type level, right?  It's just basic algebra, something we do at the term level, at the run level, day in, day out every day of our lives.  It's useful to be able to do that at the type level.  And you've probably seen horror code where people do do.
>> Jumping right into the ugly.  So talking about syntax for a language, really is -- that's the core of where most developers spend their focus, right, like this is why people love dynamically typed languages.  So we shared the lambda cube earlier this is something that's very mathematical, can you read a Ph.D. on it if you like, however you probably don't want to, so Paul put in a little table so we can see very concisely what we're trying to achieve.
>> Yeah, I want to argue for the pennant types.  What does it mean when you pass a term to a term?  Well, that's called a function.  What does it mean when you pass a type to a term that's called inheritance or overloading.  What does it mean when you pass a type to a type, that's called parametric polymorphism or or.  What does it mean when you pass a type to a type?  That's.  We saw an example of that function signature earlier in Idris and we'll talk about that a little bit more.
>> And we'll look of a different kind of syntax, that of dependent ML.  This allows us to do dependent typing, which is phenomenally great but if you don't know it and you approach this code.  What's the first thing you do?  You delete all the extra crap that you don't know what it does.  We're like, oh, cool, I get to delete code.  How many tweets have you read in the last month, I've been deleting code, I've been deleting code?  Did you remove some of the safety measures?  Likes it was there for a reason.  If I can tell what the programmer was thinking, if I can't-the-
>> So syntax matters, I think one of the things that we really want to communicate is that it's not sufficient just to have an early awesome type system.  The rest of the language really matters.
>> You can do really awesome things in Java.
>> Like this.  This is a signature from a challenge that Tony Morris put forth to provide just the type signatures for a tic-tac-toe game that could never be on in an illegal state.
>> I write Java on a very regular basis.  What -- I don't ever want to see that.  I don't know what that does.  That better be a very important piece of code that people's lives or a lot of money is dependent on or I don't want to have to go through the trouble to write it or ever read it.  If the code is it not going to change very much and it is very important to my code base, I may in fact go through the trouble of doing this.  But I'm not going to follow that old addage that comments mean your code is not good.  I'm going to comment the heck out of that.
>> Exactly, and provide links to sources and all that kind of stuff.  This is the stuff in Java I only want to see protecting other people's money or protecting lives or what have you.  Oh, yes, is that Tim?  Sorry.  Yeah, that's a quote from Tim Sweeney.  CEO of epic games.  I trotted this out two years ago, and it was old then.  It was two years old then.  But basically the point Tim is meaning can you can have all the express power like Scala does, like C++   does, like Haskell does and if you're not able to manipulate the conceptual numbers, strings and all that sort of stuff.  If all you can do is figure out what to do with those data types, that's a royal pain in the neck, and there are libraries that have gone through that pain that is awesome.  Shapeless for Scala is awesome, but if you look at the source code it is unbelievably complicated.
>> So that leads us to something more awesome, kind of the holy grails being able to use types and terms and times, everything uses the same language.
>>
>> Type level programming that is really easy, with safety, this is so awesome, this is the reason people use dynamic languages, but with safety.
>> Right.  You don't have to make all the compromises that -- let me rephrase that.  At some point, you won't have to make all the compromises that you currently have to make.
>> .
>> Oh, dependent faking dependent types, yeah.  So in the meantime, folks like Aleg Kiselyov are doing things that are purportedly only possible with dependent types in them anyway.  The approach to this is something that was actually originally done in the 70s for the LCF theorem prover, and that's why you can still program that way in just about any static programming language.  So again, it can be done.  The question is whether it's worth it is very, very domain-dependent.
>> So most of the reason that people hate types is because of false negatives.  You're changing the time changing the types casting to change things that don't really affect the correctness of your code.  If my compiler tells me I've done something wrong when logically in my own head I know that I'm doing is rect correct, I just can't do all the casting to make the compiler happy, that's a nightmare, that's what people hate about type systems and that's what needs to be fixed.
>> That's overwhelmingly the most popular complaint I hear is the compiler is getting in the way, and with the weaker type systems, that's probably true.  You probably have a good handle on the actual behavior of this piece of code that you have in your head is going to be, and all you're worried about now is getting the compiler to accept it so that it can run and do what you already knew it was going to do.  That I think is probably the best capsule summary of what a bad type system is.  It does nothing really effective but get in your way.  So you either go to a dynamic language in my own case I wouldn't be able to sleep at night if somebody's money was depending on this or you use this and you can't sleep at night because you can't compile your code.
>> It's a double whammy.
>> So with type inference is it a double-edged sword, right?  I wouldn't write code without it because I depend on it.  I love type inference, it makes my code really concise.  I want that, I love that, but I have this dichotomy, it's either incomplete but expressive, or complete but weak.
>> And from a correctness standpoint there's also the I issue that type inference gives up the most general type that it can infer which from a correctness standpoint isn't what you want.  What you want is the specific type that is actually satisfied by the implementation.  So I tend to use type inferential first of all for noodling around, just the fact that you can type and go and if you're not too concerned about your types at this point.  Even when I scale up, though, what I wind up doing is relying on type inference for 90% of my code base and for the stuff that's really critical I actually spell out the types because I want more specific types than type inference is going to give me.  
So there's a quote by Benjamin Pierce, the more interesting your types, the less fun it is to write them down.  And this is unfortunately always true, but ideally this wouldn't be the case.  In a perfect language this wouldn't be the case.
>> And I think as we get towards the more syntactically clean approaches, that will improve.
>> So you have to ask, what's the cost of proof?  Which costs more to your company, which costs more to yourself?  Not accepting a correct program or accepting a program that is incorrect?
>> Yeah, what's your loss function?  What's at stake when your program misbehaves, what's at stake? another thing that drives people towards a language is popularity, and I don't know about you guys in high school, but I bet a lot of us were really weird in school, right, some people would probably look at you and say I don't really want to spend much time with them, they don't have a lot going on, they're not very popular.  Now we're kind of the ones running the world, right?  Seemed like we were going to be very popular if we were cheerleaders and jocks, but maybe not so much when it comes to real-world importance.
>> Now that we're all adults.  So part of the point here is personality cults are not very helpful.  They're not helpful in the technology world, they're not helpful elsewhere.  I just had a conversation with a gentleman recently, bless his heart, I don't think he has spent a lot of time studying these issues, but he was talking about Go and I recommended rest to him and he made the observation that the rest community doesn't seem to be anywhere nearly as large as the Go community.  That's probably true, but is that a sound basis for comparing those two languages?  And that drives us right into culture.  The culture surrounding a language, the culture surrounding a type system.  I think Clojure has an awesome culture in some ways, they're always learning new things, they're book clubs, they're the type of people who want to learn more and grow, but Clojure has such a dynamic feel to it because everybody wants to rely hon that, type Clojure, how freaking cool, right?  Who's using it?
>> What's the uptake?  There's a huge cultural barrier there,.
>> There's also the ability for Haskell it's really hard to get into those groups, unless you have your Ph.D. in mathematics.  I don't want to be told to RTFM when I have to read through hundreds of pages of mathematical documentation in order to understand anything.  So hopefully talks like this, people who are out there trying to spread the good word are hopefully making it a lot easier, not using the mathematical terms.
>> This is not about being the smartest people in the room which I don't think we are.
>> Not by far.
>> In any case.  So there is that stigma.  Type theory is a theoretical computer science discipline.  You don't have to be an expert in it to get the benefit of a decent type system.  You know, we can actually have a pretty pleasant experience with this whole thing.
>> Yeah, if you start to look at all of the things that we said are good, all the things that we said are bad, and all the things that we said are ugly, if you matrix those together, what do you come out with?  Really kind of yearning for something new.
>> A lot of research still to be done in all of this.
>> So we put together this informal hierarchy of type systems that you don't have to be a math major to read.
>> We stole it from a blog post.  We haven't had an original thought in our entire lives.
>> So just starting with an informal hierarchy, you have this stupid barbaric horrible type systems that we all complain about on a regular basis.
>> They're lacking any of the positive features we started with in this talk.
>> But it's the first thing you want to do when you write a type system because that's the cool thing.  So you start with stupid.
>> Yeah, basic correctness, this is not adding strings and imagers, you know, just really obvious kind of simple straightforward stuff like that.  I don't have any time for languages that let me add strings and imagers, you know, I don't know about anybody else.
>> Most people here do.  I'm just saying.
>> That's fine.
>> Then we go into expressivity.  Allowing you to really say what you want to say, kind of restrict you from doing what you don't want to do, making illegal states unrepresentable, generally.
>> Right, and yeah, maybe letting you express things in formal logic terms if want, but maybe with some pain.
>> Yeah.  And then you've got Coq.
>> And when you get to the dependent type world I should point this out explicitly are you talking about a program language.  Is it a food topping or a floor wax?
>> It's generally both.  I want to understand what's happening.  So I don't necessarily need to be all the way to indistinguishable from magic, I want to somewhere between those last two.
>> Hopefully they'll get less magical as some of the syntax and other non-type system issues get solved.
>> So then we go into the more formal way to look at a type system and to judge it and you have the lambda cube and this isn't nearly as hard as it sounds, because we saw Paul's table earlier and it uses all the same words.  Using the same words, plus a little bit of math stuff.
>> Yeah, yeah, these are just some categories.  You can look at this stuff offline when the slides are available and the video is available, but this basically delineates the major features of type systems, where they sit on the cube.  The cube expresses the fact that it's not actually a hierarchy, it's 3-dimensional.
>> But there are tons of speaker notes down on the slides if you're interested in finding out where to find more.  Hope we're finding you at least some ideas that you can walk away and Google.  The hardest part is to asking the questions.  If you didn't even know that it was a thing, hopefully this has given the idea that you can in fact do that.  Just some last minute director notes it's not all about the type system, however, type systems are really, really important.  They're not created equal,.
>> There are good ones, there are bad ones, there are ugly ones and it's an important judgment call as to when to choose to take advantage of them and when not to.  Or for that matter, when to change languages and change type systems.
>> We believe that it's unethical to not rely on a type system, to not rely on a type system if you are working on an NSA.
>> Whatever that means, people's money or other things.
>> Lives, all the things that can be at stake with the stuff that we do.  And also the last bullet point really is important.  Over the past few years there's been a lot of new languages and so a lot of people are starting to get burned out, like I can't learn all these new languages, why would I want to?  So if you're one of the people that we should have one superior language that everybody uses really you need to be paying attention and thinking about where we can go from here.
>> We've talked a lot about types, we've talked a lot about Idris, it's probably about production quality to be honest.  So when we're really talking about this holy grail type system is sort of where we hope to land a few years hence, where we're pretty clearly not there yet.
>> OK, so we're out of time.  I am Amanda Laucher...
>> I'm Paul Snively.  I'm at Verizon IQ, we're a Scala shop, as well.  Come and talk to us ... :  Thanks.
[break]

