Strangeloop 2014

"Idris:  Practical Dependent Types With Practical Examples"

Presenter: Brian McKenna.

Live captioning by Norma Miller, whitecoatcaptioning.com

>>All right, we're going to get started.  So I'm going to be talking about Idris.  It's a new program language based on dependent types.  I could say dependent types are types that depend upon values and we've be done so I don't feel that's very useful, so I'd prefer to demonstrate it and tell you when dependent types actually come into action.  So this is a motivation, this is a drone that runs on NCO4 done by NICTA.  Kind of integer overflows, all memory access is safe.  It the drone itself tries very hard not to fall out of the sky which I think is pretty cool and pretty important.  There was this great presentation by [WOUT the RE?]
>>Coq is a language in the experience report he says extraction is not yet mature.  Extraction is the concept of -- is the implementation of taking formally verified dependent type code and creating an executable from it.  He says it's not mature.  Uses peano numbers.  So this is an -- so what he was doing is extracting from Coq to Haskell and peano numbers are really inefficient.  So if you have to represent 1024, you have to have 1024 objects in memory, which is no good.
>> Used a lot of unsafe cores, which is telling Haskell just to trust it, which I don't.  And there was a little blood, sweat, and shell script.  And that's no good.  In fact, he had a SED to patch the types.  So he wrote a formerly verified code, had a dodgy shell script to replace in the formerly verified output, which is not nice.  I don't want to have a sed script when I'm trying to code something correctly.
>> So when dependent types beings practical, we can see that SCL4 is a thing and people are using it to keep drones not fall out of the sky which I think is very practical but in terms of making executables, I don't think that's the case.  With SEO4, as far as I know, there's proofs written about some high-level Haskell code that implements this kernel, and there's Isabelle which is doing the formal proofs of memory access and of overflows, and then there's the Haskell layer which is the high-level implementation and then C which is...   -- so there's a lot of cost involved in that and there's a lot of margin of errors, so we can do better and I think having a dependent type language that compels to executables is the way to do that.  And I want to come up with some practical examples.  A lot of these examples are concatenating vectors together.  I'm sorry that's not very practical.  So I want to get a little bit better.
>> So here's a project called Iridium.  This is something I started working on.  Written in Idris.  About 60% Idris and 40% objective-C.  The idea is that we've got this idea of being able to interpret these effects to execute on the plat many to, so we can theoretically have it work on X11 or Mac.  So I'm just going to see it working so we can see some independent types actually running.
>> Let me create another window first.  There we go, so we see dependent types actually working here, moving windows around, changing layout.  So that's all powered through Idris.
>> What I really want to do, though, is write some independent types in front of everyone so we can learn together and I'll be able to point out where independent types are coming into effect.  So yeah, let's do it.  So the first one I want to do is prove an algebraic law about a dog type.  So I'm going to.  :  What I want to do is write a function that does a bitwise or this.  So I'll just implement this.  We'll see how we go.  So the implementation, we have to see something about X and X1, so Idris allows us to deconstruct these things, and create a pattern match on it.
>> So in the case that we've got O, and that should be x1, and in the case of I, that should just be I.  Does everybody agree that this is all?  Please don't, because I'm going to prove that this is somewhat in the right direction.  So what we should -- what a proper of or is that it's associative.  So what that means is that a or b or c equals a or b or -- so that's the associative property and we should be able to prove that that's the case.  It's not going to prove everything about the or function, but this is one step of proving the property of the or function.  So we know if we were to prove this, at least we didn't stuff is up that badly.  We might have stuffed it up, but not that badly.  So I'm going to make a function called or associative.  It takes a bit.  Another bit.  And another bit.  And this code is actually what we want to prove.  That's actually an Idris type.  The type is that these things are equal.  So the first thing, if we load this up, Idris says we're trying to prove this thing which is exactly what I wrote down and we've got A, B, and C in scope.  Now, it doesn't know what the a, b, and cs actually are, so what we can do is again pattern match, load this up and now we've got different things we have to prove, so we have to prove that or b and c is equal to or b and c, that's pretty easy.  When Idris knows it's exactly the same they actually show it to.  It's the same thing.  The other goal that we had to prove is that I equals I.  I think that's pretty easy, as well.  I'm not actually typing it, like Idris is constructing my program for me.  All we have to do is pattern match and it found the program for me.  Which I think is pretty awesome.  Now, or probably isn't very practical but I've got a little bit more that we can do.  So we've got this bit string which is a list of it.  And you see how I've just defined a type as if it was just a value?
>> So what we'll do is make -- we'll call bsor, just because.  So this will take a bit string, another bit string and another bit string, so this is all bit strings, rather than just one and again we'll get Idris to -- we'll see what Idris will pattern match for us, and so what we'll do in this case is just accept whatever Idris has given us.  I don't know.  I'm just making this up:  Is that right?  I think it's banksly [ph] right?
>> In this case, though, it's going to be more interesting.  We don't want to accept whatever Idris gives us.  So this one we'll do or.  These two.  And then we'll do one do.  Something like that.  I don't know if I'm doing it right, but Idris will quickly help me out and let know.  So we've got these bit string or, and we'll do basically what we did before.  Except now we're working for bit springs rather than just a single bit.  Does everyone seen what we're doing?  We're doing it over bit springs rather than just bits, so we're proving whole strings bitwise or over whole strings.
>> So Idris is going to tell us what we need to prove, which is exactly what we just stated.
>> And what we can do is accept whatever Idris is going to give us.  So in the case that we've got an empty, we've got the empty bit spring, then it's the same, it's b is or b and c and we just keep key deconstructing each of the fields and in any case where we've got an empty one, we're done.  Once we get an empty bit spring, we can prove that it's just using the other two.
>> Now, this one's a bit more interesting.  So this one's asking us to prove that these two things are the same, and there's more things going on here.  Associativity of or which is different and then Idris is proving the associativity of the rest of the list so what we'll do is go up here and Idris are ask us to stop proving things.  You can actually write proofs in a different sort of language is which is a bit more familiar for most people and.  Here's the goal that we have to prove, that or and or associative.  We can see that they're different and we need to make them the same thing.  But the goal is to make these two things the same thing, these two ors this one and that one.  So we've already proved that or is an associative, right?  So we can rewrite that goal with our proof, and you can see that -- can everyone see the difference there?  So we've proven that the first part is the same, so we're partway there.  And what we should also do is prove the last part.  Do those things look the same now?
>> So we've done it for the second -- we've proven that the first part of this list is the same.  We've proven that the tail of it is the same.  We can write now trivial, and here's the best part, you write qed and then you go Idris inside out and so it's proven that our bit strings are associative.  At least got that right.  I might have gotten some other parts of the algorithm wrong.  I've at least proven this property.  I'll stop there and move on to the second part.
>> So that goal was like correctness, we could prove certain properties.  What I want to show now is the expressiveness so I'm going to make something called a bin char and we'll do something similar like we did before.  We are can put the character into the type.  That should be a 1, there we go.  So now we've got those two constructors and they've got a value thing and they've got a value at the type level.  So now what we need to also do is have some -- I want to make a proof that everything in the list can be of something.  Hold some sort of predicate.  So this predicate is actually going to be from some value into a type.  That's going to be how we predicate a value.  And then I'm going to have a list of those things.  So the proof -- so we'll have a list of values, and also the proof that a particular value -- sorry, we'll have a proof that the predicate holds for each of those values.  This curly brace is actually for saying something is implicit.  So you don't have to give it each time when you're trying to construct this.  Idris will try to figure it out for us.  So we'll have some predicate and I can make an every, so if you give me an empty list, that predicate holds.  If you give me columns, and then you have to give me a value that that -- you have to give me -- you have to show me the predicate that that value holds for, and then give me a -- sorry, give me the tail.  Oh, yes.  Thank you.  So for a value that the predicate holds for, and a tail, so for the rest of the list that this thing holds for, then we can just put that value onto the list and say that it holds for everything in that list again.
>> And then I'm going to write a function that says for every binchar that's on the list, we can get out -- given an natural number, so this is going to be converting from these binary characters into a natural number.  So again we'll split.  And what we have to do is actually split a little bit more than this.  What we have in scope is just some binchar.  We want to actually do something a bit more interesting than that.  We want to see what type of binchar it is.  So in this case, we just want to recur in this case it's 0.  So it's zero, it doesn't add anything to the number.  And we'll just this accumulator is sorry the count of how many bits we have so we're just decrementing that.  But we want to raise 2 to the power of k and then recurs.  I don't know if this is the right thing, either.  I'm sorry.
>> But what we're going to do now is that given a string, we can also ask for a proof that everything in that string is a binchar.  And so I can't remember the name for going from a string to a list of characters, but what I can do is search for it, if you can see that.  So Idris kind of has a built-in Google into it which is pretty cool, and what we're seeing here is unpack.  So unpack S.  So what I'm doing is unpacking the string as we get for an input and asking for evidence that everything in that string is a binchar.
>> And I shut printout on that.  So this is actually using the proof so we can use the proof at the level.  So we're going to say this is going to be from binchars and something like that.  So I should be able to load up the -- right, so Idris doesn't find the evidence -- it doesn't automatically find the evidence that every character in that string is it a binchar, so Idris actually has a feature and you can just put auto before that and it will do the proofs like I said before of supporting for the proofs, it's going to do the same thing.  So if I reload this, this code should not work.  Supposedly that's 23.  I don't know if that's true.  I know that's 3.  So you can see that we've kind of made literals in some sort of sense because we can't type in that.  Idris is not going to be able to find evidence that that's a binchar, because none of those digits have binchars and it will only work if you put in things like that.  What we're going to actually do.  Is that 5?  Let's go 4 and so if we go example 1, so it will say it's a completion error and actually give us the real thing so we can actually even leave examples of our program inside as types, and say, this thing holds true and if we were to modify any of our functions, it would only compile if this also compiled, which I think is pretty awesome.  It can leave examples in and only make it compiled if the value level holds which is pretty cool.  And so I've got one more example.  And this is probably my favorite one.  So I was looking for some sort of an example of computational complexity, so I asked my coworker, what's something that you've done recently where the computation complexity wasn't very good and he was describing this algorithm where he had to compute things over days for every day, and so every day depended on the previous day, so for day 1, it depended on day 0, which didn't exist.  Day 2 depended on day 2, and day 3 ended on day 1 and day 2, so you can see that this is growing in a bad way.  I'd like to prove something as of factorial complexity, which I think is pretty cool.  So what I'm going to try to do is make a data type called cost.  So we're going to make a data type called cost, it takes some sort of type and it also takes a nat.  But that is what it costs to compute that value of that data type.  And a constructer, going to actually take the cost, because it's at the type level, we don't really care.  We'll just carry it around the type level, we don't need to carry it around the run time cost at run time.  So I'll make a function called uncost, we'll take a cost Idris just wrote my program.  That was pretty cool.  But this will take the value out of the cost.  This cost data type I've just created so we can just use it without having to worry -- without having the type -- it will contain the cost.  Also I'm going to make this a we'll take a return, just take a T and give us any cost if we wanted to say return and say the cost is 1,000, we can do that.  We can make any value any cost, which is a problem and it should probably be private, but I'm sorry.  OK, so I'm going to write a monad, so this is going to be the blind, so given a cost what should the cost of this mon yard be?  Anyone take a guess?
>> N plus m, which is pretty cool.  So if we have these dependent computations, it's just the cost of doing those both ways.
>> So I'm doing something not very nice here, so but we calculate something, we calculate the B cost, so the cost of doing B, we actually remove the cost completely and we say the cost is actually n plus m and but here I'm doing something a bit loose and I'm just saying trust me.  I.  There's no verification here.  I'm just stating that blind means n plus m.
>> So what I want to do is write a function that says given some -- tell me to do something n times.  And something that costs something.  And also initial value, like an accumulator.  Then the cost should be, anyone want to take a guess at this?  If we're doing this cost n times, what should the cost be?  Yeah, so the cost is just going to be doing that thing n times.  It's really simple:
>> In the case we get to the end, so we've done things n times, in the case we've gotten to the end and we need to do things zero times, then we can just return it and say that the cost of returning this value is zero.  So this return, the actually the type of it is going to be cost of zero of a.  In this case, we can start using the do notation.  This will be the cost, this will be the accumulator.  So if we do the thing, if we get the value out of the cost, the cost that we get passed in, they we also want to recurs and do it a few more times, and just append these things together.  I'll do accumulator plus.
>> So Idris has just verified that that is in fact n times m.  It should not compile.  There you go.  Yeah, so we haven't proven that -- it's asking for a proof that -- sorry, it's saying that the -- they're not the same thing, that n is not n times m, it's not actually saying that but if you keep going and keep increasing the bounds, that's what you get to.
>> So going back to my coworker's problem, he said that for n days, it was a factorial, the cost was factorial, so I want to -- this isn't his problem, this is not what he was trying to do, but I want to show you something with complexity of factorial.  String, so we should be able to construct some sort of value that has this cost, has the factorial cost.
>> So I don't know, this is a function that should theoretically, yeah, it type checks, so it does something factorial n times.  This is because we're coursing over doing the day and we're also doing it n times.
>> So I'm just going to show what this outputs, because if I ask for a day o, see you can see that it's climbing up in cost, so it went from cost of 2 to cost of 24.  Say cost of 5.  That's going up to 120, right?  And you can see that it's making some big stripping.  What if we ask for day 7?  It's going to be kind of costly.  So this is some huge value.  Is it like 5,000 or something?  I don't know, so it's some huge string.  We probably don't want to ever compute it, so theoretically we should bound this and say never be able to compute anything more than 7.  So theoretically can I make all of this private and only expose this function when I say only do things that are less than 7.  So there's a function like that can go from, so fin is actually there's a cool feature in Idris here, if I can remember it.  Here we go.  So we can say like, we can ask for documentation, so fin is something that's less than some bounds, we can say fin of 7 would have to be some number less than 7.  So we can run programs as long as you give me a number that's less than 7.  And we can also ask for a natural number, go from fin of n to a Nat and here we go, there's a function for that.  All right.  That's going to give us a string.  So we should be able to do that fin to Nat thing again.  And if we only use one or only exposed one in this module, we could run anything that's less than 7, but we can't run anything more than 7.  Or we can't even run 7.  Must be less than.  So it's pretty cool that we've proven that -- first of all we've proven that the cost of evaluating this function is factorial, so the computation complexity is factorial, it doesn't necessarily have to be computational.  We could theoretically make this memory.  But we've proven that it's factorial and also made a function that and made it so you can't run factorial for anything more than 86.  Which is pretty cool.  Is anybody impressed by that?
[applause]
>> I was.  It's pretty cool.  Yeah, so you just learned the ABCs of -- I'm sorry, the algebraic laws and binaries and complexities of Idris.  I think this gives some motivation.  Algebraic laws give some motivation for correctness, if we were to write a lot of algebraic laws about data types, we could.  I've given some idea about the expressiveness of types.  We can have.  They can be converted into a natural number and we can just use them.  I've also shown that we can track computational complexity inside the type system and we can put limits on what we would like to execute.  But what I've showed with the complexity is that we can calculate exactly what it is, but we could also theoretically have best case, worst case and average case.  There's no reason we can't track that.  I also showed that we could write examples inside of our programs and only let them compile if that example actually worked at the value level:  We can just write them as types inside of Idris.  That is all the content I have and there's one final photo of my dog.  He's at home at the moment, I assume.  Yeah, that's it.  Thank you.
>> We've got 6 minutes for questions.
>> Yeah?
AUDIENCE MEMBER:  So when you implemented the -- [inaudible] what you did that wasn't that effectively [inaudible] you were just asserting that it's n plus f,.
>> Cost is an assertion.
>> It's a cast.
>> OK.  I'm happy to -- yes, I have to verify that.
>> [inaudible]
>> I guess the fundamental question I have is, how is it that the proof:  [inaudible] yes, Y does have to be correct and everything is it predicated on that, yes.
>> That's pretty cool.  Even if it's a cast.  I don't know.
>> We've got to have some more questions.  I've got like 6 minutes, so -- --
>>
AUDIENCE MEMBER:  [inaudible].  
     If I wanted to use that function with like a string I got somewhere else, can you speak to what I'd have to bring along to be able to do that?
>> Yes you have to do it exactly that.  You have to give me evidence that everything, any list can can be made into a binary character so you have to prove to me that everything in that string has binary ...  Yeah, very easy.  Yeah?
AUDIENCE MEMBER:  [inaudible] 
     It sometimes works.  What do you mean by through pulls?  I don't know what that --
>> Right, you have to manually have to pass through everything and show evidence?  Um, the question was, how well does Idris work with actually having to carry through proofs everywhere throughout your program and show evidence to the propositions that you're claiming.  Like I showed like here we've got these curly braces, that means it's implicit so don't actually have to provide it to Idris, Idris will find it in the environment.  So that's the first thing.  And also there's proof theory but that's for things like literals.
>> So yeah, [inaudible].
>>
AUDIENCE MEMBER:  [inaudible]
>> So Idris can infer lot of things.  It works by unification, so if it cease something at the value level, I'm sorry if it cease a value that has the right, that has a particular cost, then it can infer that that cost is that thing.  So what you could theoretically do -- I don't know if this is going to work, but we'll give it a go.  So let's say we've got F which takes a cost, let's say it cost 2 to compute this string.
>> .  And we have G -- I don't know what the cost of this is, but it's going to use f:  OK, so it wants me to prove, so it's not going to work.  So usually what can happen is Idris can sometimes figure out what that nat actually is, sort of said 2.  For some reason it's giving me nat, I'm not sure why.  Yeah, so it doesn't actually give me that.  But there are some cases where you can just leave in question marks and just say just search for the evidence that this is, so you could theoretically do, proof search, I think it is.  Oh, there you go.  So I could ask what's the cost of G?  OK.  Does that work?  Here we go, if you say 3?  There you go.  So, yeah, so you can see that it's inferred the cost, so we can put in, we can say that's the cost and it's going to return a string, we don't have to fill in the particular cost, we can let it be inferred by Idris doing a proof search.  A lot of people dependently typed language have bad inference but in my experience that's not true.  It infers a lot of things.  I've got almost I think I've got no time left so if you want to come talk to me, it would be awesome.  I've got exercises for people to play around with and I can work with people.  I really want to get people interested in Idris, and I didn't mention before, but I wouldn't use Idris in production.  I'm not trying to give you impressions that Idris is a perfect language.  There's actually a couple of bugs in here that I didn't want to point them out.  Actually I'll point them out.  I've got a few seconds.  Notice how there's a squiggly line here, it's actually giving me a warning that this thing is not total.  But it is trust me.  I know more than Idris.  If I rewrite this in a different way, it's total.  You'll have to trust me that that's a bug.  But yes, if you want to work with me, playing around with these things, like we should be writing blog software in Idris, probably shouldn't be writing production software, but let's write common markdown, lets start formally verifying that, I don't know.  I don't recommend us using it at work right away, because there are bugs, but we should start playing around with it.  So thank you.
[break]

