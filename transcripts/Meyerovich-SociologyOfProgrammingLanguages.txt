Strangeloop 9/18/14

"The Sociology of Programming Languages"

Presenter: Leo Meyerovich.

Live Captioning by Norma Miller, whitecoatcaptioning.com.

>>  ...  So hi, I'm Leo Meyerovich.  This is work I did with Ariel, who's now at Cloudera, and this is from when we were back at Berkeley and we were looking at the sociology of programming languages.  It's kind of overselling a bit.  It's a really big area that just not a lot has been done on, so we actually just focusing on let's just zero in on adoption, so a bit of a bait and switch here.  So a lot of these things kind of generalize and -- what I want you to think on a higher level.
>> This is a source of pain or cognitive dissonance I have had in the last 12 years or so.  We do static analysis and all these sophisticated things.  Now at our startup we're kind of looking at how do you do GPU programming?  
     Are we good or --
     OK, we're good, OK.  
     Great so yeah and nowadays when we're working at startup on G.  We now how to make things faster and how to use languages there, but on the other side, there's kind of this unease about when we're actually starting to think about what are the people on the other side of these things.  And so I'm kind of curious, like Strangeloop, I kind of always like coming to Strangeloop because there are a lot of builders here.  So who here has made a language or a framework or some cool software that you're proud of about.  Keep your hands up.  Did it make one of these things better?  OK so most of the hands are still up, right?  Now, did you make tradeoffs when you had to start thinking about adoption in people.  All the hands went down.  That was my problem.  All of the hands went down.  Like, hello?
>> No.  Oh, no, except for one.  OK, so we have -- I'm very happy for you.  I'm very envious, actually, like I wish I was there there.  Yes, and actually, yeah and racquet con is on Saturday and so you should go there to learn more about why that is.
>> So I'm kind of not the only one.  We're not the only ones here.  One of the inspiring moments was this essay by Eric Meyer on confession of a used language salesman.
>> He said his kind of career took a U-turn when he discovered something called the change function.  And the change function is about the threshold to adopting something, like when will somebody change their habits and pick up a new technology and basically it says that when the perceived need of the adoption, like the benefit is greater than the pain of doing that adoption, then you'll actually, the user will go out and pick it up.  And so Eric was taking a look the a his work with Haskell, so Eric Meyer, visual basic, Haskell, he's Sharplink nowadays and stuff like that, so he was working at Haskell with all of these wonderful -- a lot of wonderful things in it.  One of the hard parts about Haskell for all of these benefits it's a new language, new sin text, no build environment and all these kind of stuff.  He said from now on my goal in life will be also to drive the denominator down to zero.  That's his new approach to language design, entirely driven by thinking about the people.
>> So we can actually see this in his career.  He left the Haskell maybe not left the Haskell community but he joined the Microsoft community and he would still be working on these beautiful functional programming concepts, and he'd -- instead of doing a new language, he'd embed it in existing languages.  And really designing around this change function.
>> So at the beginning of the talk, I said this is about not just adoption but something broader, and I really when I say sociology, I really mean groups of people.  So to get a feel for that I typed the word coder into Google image search.  We have some sort of nerd.  There's a category of nerds which apparently is a guy with a laptop and I don't know, there's like a ninja with, like, poking himself with a sword somewhere there, and then you know, a coder is a coder, maybe hackers are cooler, let's look at what hackers are.  Now it's ski masks and apparently you sit in your monitor, something like that, but it's always like, I don't know what's going on, but it's always one person and the bits.  It's man and the machine and some cultive personality type of thing.  In reality if I look at actual impressive computing systems, there's like a few guys in suits and then a couple women actually doing all the hardware worked and that's reality and then when I look at GitHub, we have like, I don't know how many millions of programmers on GitHub.  It's this very social thing.  So I need to not be thinking, less ninjas in ski masks and more groups of people in the data center, stuff like that.
>> So I've been kind of -- I want to kind of get across in this talk is basically I think we can design smarter by exploiting social foundations.  As a part of that we need to get more knowledge.  So I'll talk about what ariel and I have been doing unthe empirical side and also on the theoretical side.  There's a lot of stuff that we can lift from other communities that have studied how people work together.  So one of the broadest areas that we -- and one of the basic fundamental questions is how does a language grow?  One inspiring area from social science here came up with this theory of the ecological model of adoption, and we can kind of understand this in terms of how music spreads and how does that grow?
>> And so with music, like I love music, like there's this Canadian reggae band that apparently I'm the only one out of my friends group who likes and that's a very big oddity and for that there's something weird going on.  It's like we don't all have time to listen to weird Canadian reggae bands so in reality music generally spreads through your friends.  Think of who your favorite bands are and who your friends' favorite bands are there's some sort of intersection?  The ecological model is kind of looking at -- is kind of looking at people as sort of a resource, that like the music grows through people, like you can't have multiple, it's hard to have multiple, like all the music on one person, so that it's kind of this battle over people and so we could look at programming languages and there's kind of very natural process, we can see here.  So maybe somebody starts using a language in a niche where I don't know, I'm a big JavaScript junkie for better or worse, then libraries grow, so there's this whole no JS thing, and now today, we have JavaScript is basically on the server and it's getting today even in hardware, for example, our again our startup we're looking at JavaScript for GPUs for example, and so we are seeing this kind of virtual cycle of the spread.
>> And so we decided to look at the data to see if maybe we can start fitting some of these adoption models or getting some insight and so I'm going to be talking about a few different datasets here so I wanted to do it all in one go to give you a feel for it.  The first one was a dataset that we got from somebody else.  So David McIver had been running this site and basically we got about two years of survey results from him from about 13,000 different people compared different programming languages and how they thought about this them and from there, on home page, if you Google my name hopefully you can get here we did some data.  So the COQ theorem prover is often correlated with I often feel like I'm not smart enough to write this language.  I actually suggest you play around here, maybe you'll find some different languages or see different ways of looking at your favorite languages.  The real reason we did that was doing those visualizations.  Especially Jean on the right, you can tell she's cool because she has the sunglasses -- actually, she's in the job market.  We got people to answer our own questions about what they actually did for the real job for real projects, and there we got, I guess about 15, 1600 respondents just saying what they actually do.  This was interesting data.  At same time, back then we were at Berkeley, so this was this thing called MOOCs going on, these online courses.  We are worried about the datasets there.  We were worried that they would all be students, they wouldn't be interesting data.  But in reality, the people who take MOOCs people who have day jobs.  So that was actually an interesting dataset so both of those surveys were biased towards working professionals, and then finally, you know, people are subjective, maybe we could look at the real data, so we look at a lot of our repositories.  Over ten years of projects, that was, I think about a quarter million projects and then also more recently and I'll sprinkle in a bit of GitHub and using those things.  So using that, let's start digging in.  That's kind of a very high Level 1.  Again we want to look at how languages grow, in particular through niches, and we took a look at projects in source forge.  And we're looking at the Squirrel SQL client.  We know the name, the programming if we look at blogging out of all the niches, it's kind of lower, like maybe 10% of the blogging projects are in java, but if we look at a more popular use of java, it would be search.  And at the bottom we're look everything at Scheme, or maybe, maybe Racket, so this is before the name change, so probably Scheme.  So here it's in more particular categories, for example, build tools jumps out from the bottom and also note that the Y axes are a little different here.  So the Y axes, we're dealing up to 60%, while scheme it's kind of more growing so it's more at this 3, 4% range.  So what we wanted to see is are those fundamentally different languages?  Why is java so general, while scheme is kind of more specific categories, and so we've plotted that out.  This is the column the dispersion.  I don't really want to explain it but think of the java in general lots of niches on the left and on the bottom right is less popular and used in more kind of nuanced specific niches.  We see there's actually this very gradual er curve so if you think back to the ecological model it kind of makes sense that you go from niche to niche to niche.  So to me it was interesting to get that validation of correlation, causation, whatever, but it was interesting data.  Using a kind of originally we did another analysis, not actually originally the source forge data but there was a problem with that so we actually used the survey data here, and what we wanted to understand is more of those niche languages and so on the X axis I'm plotting out different languages and on the Y axis I'm plotting out their popularity.  I think I lost the label is java, and so almost 10 to 20% of the projects are all java and there's kind of this winner takes all feeling.  If you're counting on having hundreds of millions of users you're in for a rocky time.  What's interesting about this graph is it's something called the long tail.  I think in startup era, I think we're all familiar with that but what that tells us is we have basically a lot of languages that can live in the long tail so if you find your special something, you could find your market share, I don't know if profitable but at least a sustainable community that actually uses it.  To me that was very heartening.  Like maybe you won't win the lottery but at least you'll get users and build something legitimate.
>> So that was kind of a very macro level trend of how do languages grow.  Now I want to kind of zoom in about the programmers at a more personal level, like how does a programmer think, how do they act, or how do groups of programmers act within an organization, that type of thing.  And sometimes in a hobby project maybe I'm a kid in a candy store, but most of my coding nowadays is with corporate and withs groups of people in an open source project so there are constraints so we kind of wanted to understand a little bit of that.
>> So looking at our survey, this is interesting, we asked about your last project and about 80% of people answered work project.  So we saw how what they kind of prioritized for when picking a language.  And what's really interesting about this is I was expecting, actually if we jump back, I was expecting things like permanence or speed or safety and all that stuff I was expecting that to be the important stuff.  Those are all sort of in the middle.  The kind of the 50% kind of -- I picked it because it's fast, maybe half the time, something like that.  But when I look at the, you know, the 60, 70% type of stuff, that's open source library is number one.  I picked it for the batteries being included and not in general but I love to follow up was it your particular domain or just general libraries?  And the other part was more even stepping back from software, I was just looking at the organization, the community, is it I'm familiar with the language, my teammates are familiar with the language, we have some legacy code and we actually have some more numbers there, about 30% of the time is just what was used in the last project, things like that.  So that was interesting.  So when we're designing for adoption, this is what we need to keep in mind.  That was pretty eye-opening to me:  Then kind of digging deeper into like, OK, well, that's how a programmer picks for a project, but how about for a career?  Like, how does a programmer just as how we might choose a foreign language, how do we pick a computer language over time?  And there's kind of this ugly quote in I think it's the New York Times.  They're saying baby boomers and Gen Xers tend to know C and SQL, and Gen Y knows Python and Hadoop.  If that's not good.  If the pointy-haired people are thinking this way, maybe it's true.  But if we have data, let's take a look.  The first thing is we just asked, you know, for different languages, what's the spread of people knowing them?  And sites interesting, OK, Javascript and Ruby, those are those Gen-Y languages, yes?  It looks like a mean of 30 years old.  In reality it's all the same.  It's a very flat graph, because like we all know everything.  So maybe -- that was good, OK, so now we have some data to back that up.  But again thinking back to like natural language versus computer language invented language, what's interesting to ask is how do we go through languages over time.  So at any point in time, we ask people how many languages to do you know well or we ask them to list out and ask them to list out the languages they kind of know well.  So the ones we know well are in green, so we bucketed it by different ages and that's the X axes.  So again it's kind of a boring graph.  But like across all the ages generally you will a' kind of know well maybe about 4 languages, that's your working set of what you feel comfortable in and say maybe one or two languages that you kind of sort of remember.
>> So it's not like you have those for life.  The key part is with that previous fact is that's just what you keep in memory and then over time you will kind of page in, page out, learn new things and so as a designer, I was kind of curious, how does learnability, can we start putting some numbers to that, I mean not how to design for it but what should our goal be.  So we compared for different languages how long people said it took for them to know it well and this is kind of a very subjective thing so designing these types of things is not easy.  For this one, I think it is somewhere along the lines of that you felt proficient in it for whatever that means and what was interesting here is most of them are kind of less than 6 months, like except for the two on the left, which are C and C++   which basically are not managed languages and so for those it will take maybe a year or two years, something like that.  So that was interesting for me if designing for learning and as part of the adoption process, manage definitely is a big part here.  That's at least one thing we could say.
>> And finally, for anybody who's had to kind of on-board a junior developer or thinking about like recruiting and this kind of ability to you know, maybe you're a polyglot firm and you're having to teach people new things there's a question of what you have to actually teach them and there what's interesting is to look at categories of languages so there what we looked at was the probability of knowing a language given in school you learned something about a related language.  And so for example, in general, I think functional programming, so look at these different categories, like functional programming, low low assembly languages, more mathematical ones, let's focus on the schemes and the MLs of the world.  What's interesting is that your CS degree doesn't matter.  I'm sorry.
>> Might have been expensive, but maybe matters for other things, like you know, I care about languages, so for that it apparently, CS majors will a quarter of the time and nonCS majors will know them 19% of the time there's this 5% difference.  It's fun but when you and then wow, we go from 15% to 40%.  So now if you actually sit somebody down to learn a category of language, they'll actually retain that and then I was thinking about this, there's some Peter Norvig, I believe head of Google research these days, he had this great essay in how to learn a language in I think 9 years or 10 years.  And one line was learn at least half a dozen languages.  And that really meshes with for that when we're talking about on-boarding people, that this is the hard stuff, getting somebody going from Python to Ruby, that's easy.  This is what we need to think about.
>> OK, so stepping back up a level, we have a bit of a feel for how programmers kind of on the data side.  I want to actually now go back to the theory side and see what we can learn from sociology here.
>> Here I was very inspired by a field of research called, diffusion of innovation.  Has anybody actually heard of this before?  Ooh, OK, we have like somebody over there, OK if you remember anything at Strangeloop, ignore all my other stuff, this will serve your career really, really well, just in your ability to build things and so this is really important.  So what happened here is basically is maybe the beginning of the data science revolution was maybe 1920s, 1930s, and what happened there was basically -- sorry for anybody who thinks it has to do with math or anything like that.  What was really happening is we started having data.  And data about how people actually do things.  And so what was going on is there's somebody who's at the agricultural University in the US was looking at how come farmers are not buying genetically modified seed corn?  Part of it's probably that's a terrible name for anything.  Like especially for your like, how to shift your livelihood, but his question was we know this will increase your yields, this will like, you know, because less like insects are going to be eating things, it is actually a natural process, because back then they didn't know how to do any low-level stuff, it was all just about breeding stuff like that.  But they actually went from farm to farm, and started recording data about how people actually adopt things and back then we were starting to have more usable statistical methods and we were able to have both the data and the analysis, so data, science, so that was kind of an exciting thing.  And from there, you know, genetic corn is it one thing, but since then they've looked at pretty basic stuff like how do we convince people to not drink dirty water?  If I gave anybody here a glass of dirty water you would not be happy, right?  But that's a big shift and actually today in parts of the world that's a big shift and so when we look at programming languages like static typing or anything that we believe is good, it's sort of that same problem.  So there's this diffusion of innovation yes, sir.  Only one person here that is heard of this but I was going to skip this slide.  You know what?  This will be good.  You should do your homework, I'll post these slides and you should read these.  I will walk through actually an example, even better.  So there's a process that people go through, each one of these steps.  And let's do an example.  Like I really like step No. 4.  Let's say you've decided to adopt something or we're going to use this genetically modified corn on my farm, now we need to try it.  Like, you have this technology and now we need to try it.  For the seed corn case, they said, well, it's easy to try because you don't have to use it on your entire farm.  We could do the experiment and we could see the results.  So that's a very trial of technology.  And it's kind of common sense, but you know, 500, 1,000 studies later this is really what happens.  And at the same time, there are catalysts so for each step, things that make them go faster, slower, things like that, and sometimes they apply to multiple things, and so kind of an interesting example that I think is very extra-pertinent to programming languages is we look at something like kind of a case study on safe sex in the 1980s, so there was this kind of epidemic going around in the US kind of resurgences around the world, but basically here's this again it's a stupid common sense thing, but it is a technical innovation is how to prevent yourself from disease and it has a clear relative advantage that you will not die.  That's supposed to be decreased risk of death, that's good.  It's a simple process, great.  On the other hand, it's not observable.  How do you tell 23 your friends are using it?  How do you know that somebody in the next village is using it?  That's not an observable thing.  How do you try it out and decide that it works for you.  Like I try lots of things and I don't die.  It's like you know -- maybe I don't try all the things but I try a lot of things and I don't die.  So it's hard to establish causation when nothing happens.  And finally there's compatibility with lifestyle that like now you know, now involves two people, a team, whatever, it has to work with everybody, like on the farm it's important that for example if all the supply changes change.  That's a big quern concern, like in the cloud we're seeing this big shift so there's' notions of compatibility.  So why I bring this up is something I think a lot about is safer software.  I think a lot of people do.  And this kind of absence of like death that's kind of like static typing, it's you know, like the shuttle will not explode, that type of thing.  And so I think there's a lot to learn here.  And so I want to kind of look at how they went about it and once you think about this way, it makes a very new approach to design.  So in this case, again remember 1980s, so I think people were wearing neon and like I guess yoga pants even back then, so think kind of like now, but more neon.  And so these researchers, you know, white lab coat, clipboard, they went to gay bars and it was kind of nuts and they identified opinion leaders, like people who were there pretty often, peep people who were the center of the crowd, like the most neon pants or like the headband and they taught them about this technical innovation, and it's like this, you know, this is going to save lives, you should know about this and what's more we'll teach you how to tell other people, and what I really liked is they gave them silly hats, actually they gave them mines, they gave them a pin with a traffic light and now all of a sudden you had all these cool people wearing your neon headband, your yoga pants and the pin.  And that was the catalyst, you can see that other people are doing it.  You could say hey, I like your headband, but what's with the pin?  And that was a big deal.  Now all of a sudden, whoa, let me tell you about safe sex.  Great, now you have that opener.  And what was great is they didn't A already B test, or maybe we called them A/B test back then.  15% more good behavior be, 15% less bad behavior, so it's like a 30% sift.  You know when we're talking about saving lives, I feel pretty good about that.  I would love to duplicate that for our stuff.  I think there are some great examples of technology that has succeeded in terms of these principles.  So for example trialability, there's the static analysis company, you actually not only, you know, Scala is free, you'll pay covert to do static nal sis for you.  Does anybody here pay for static analysis?  Ooh, shame.  But there actually are kind of I guess in the bigger corporate world they've actually made a lot of in roads.
>> Then on the relative advantages side we look at something like Hadoop, all of a sudden you can program your browser.  ...  So I think it's useful to think about this stuff.  OK.  Last thing I want to talk about is now that we've kind of -- I hopefully have gotten you thinking more socially and thinking about groups, thinking about both the data and the theory side, there might be ways to leverage it.
>> Thinking about again what we kind of care about in our languages.  So the first one I want to talk about is productivity.  This is something that's already happened and I think the case of stack overflow is just phenomenal.  If we chart over time how many new answers are posted to stack overflow, we see that we kind of did this, you know, several orders of magnitude over about 4 years, so this is great, you know, there's a line that's up and to the right.  That's wonderful.  What's really cool is when you do the cumulative distribution of this.  And so if we look at -- actually run over here.  So we look at the 50% line, it kind of intersects with 2012, which means by 2013, half of the content on stack overflow was just made in one year.  Somewhere between 2011 and 2012 there was a big shift in terms of how people program.  Which means instead of going straight to documentation, you would go straight to Google and instead of Google returning you the information, Google will reprogram you to stack overflow answer.  And actually I know new users who say screw it, we're not going to have our own forum, we'll just go to stack overflow.
>> We do more data analysis where I work now and there I'm often trying to fit curves.  Actually for this work I had to fit a bunch curves.  And I kind of feel dumb sometimes.  So in this case I need to install it somehow, I need to import it, I need to find those right indication, I don't even know if those are the right libraries and I kind of feel that as soon as I'm saying this, I should be pointing to other options in case these don't work out.  And I'm like OK, and once I start processing these, OK, let me try to fit my data to some sort of exponential distribution.  Well, if if it's not the exponential distribution?  What do people do after this step, like maybe if it's a power log like we saw, what's the next likely think?  Finally, I need to do some post processing.  I love data visualization, I need to see my answer, maybe I had a bug so I want to see some data.  So for each one of these steps there would be these very common things like if I talk to our specialist, oh, well, if it's not the fitness package, maybe it's some data analyzing package or something.  So there's a wonderful talk yesterday about Joel on code hints that he would do it randomly, but I love to see what are the things that people do and now we want to use our collective knowledge to improve our programming experience and this is actually a very sparse space.  Let's say we want to improve how we do safety in our languages.  There's a lot of fuzzing that goes around today.  Better than unithe problem with the fuzzing world is it kind of often gets bogged down and you can't get good coverage of the but in reality if you're a web shop and you have millions of users, chances are most of those lines of code have been traversed by somebody.  And so shouldn't we have traces of those and just generate our tests from all of those unique ways of traversing the code?  So for example here let's say we have some control flow graph of a program that you know, you start at the top, you run some different statements, some are in the middle we branch because there's an "If" statement.  Maybe we run a solver but for the ways that maybe we can't figure out that magic number was 312, maybe some user actually hit that in because that is an interesting use case for a lot of users, we should have that recorded.  We already do there are to Analytics and to improve how we build our software or improve our product, why don't we do this for how we improve our software.
>> So jumping back up a level, what I've kind of talked about today is some scientific tools for grasping this normally fuzzy concept of sociology and social interaction, and definitely big focus on adoption, because that's just where we started.  Particularly we're looking at empiricism and theory.  You can look at our results, a lot of results, a lot of this, you know, just run a survey and you can actually get a lot of knowledge really quickly and hopefully I've changed the way you think about how we design these systems.  Maybe we still think about productivity, and safety.  We're not lone hackers in the basement.  I'm going to kind of do one last quick plug here.  Tonight I'll be doing a kind of a birds ton a feather unsession thing where we actually talk about here's the soft stuff that's kind of cool.  I'll be talking about all the crazy stuff what's happening with data visualization and hardware stuff like render farms and connecting those to the browsers and machine learning, all that good stuff.  Cool.  Thank you.
>> Any questions?
>>
>>
AUDIENCE MEMBER:  [inaudible]
>> From the very beginning from the time you touched keyboard to time you touch keyboard never alone.
>> So the question is one of the lessons or the lesson that we should teach people together, not as individuals?  I think that's -- I don't know if our data says that, but I would definitely believe that.  Like I know some wonderful auto didacts, but they're definitely the minority in that, yes, I would agree with you.
>> Any others?  Oh, yeah, there's a hand back here.  Sorry, the lights are all in my face here, so I'm a little slow.
>>
AUDIENCE MEMBER:  [inaudible]
>> Yeah, so there's this wonderful talk recommended and it's actually which is about basically how do you start from basic primitives and have a very simple language a from there still build up more and more abstractions and I would actually again point back to the racquet community, where I think about some things about compatibility and it just blows away a lot of the complexity you need for adoption and I'd say growing a language or this paper by Sam H and others called language is a library is just wonderful here.
>> And one other there.
AUDIENCE MEMBER:  [inaudible]
>> What are the most useful diffusion catalysts?  Um, ooh, I think there are a few.  Trialability, like the -- how fast you get to hello world is this huge, huge thing, like you know, for example for me, for a long time Haskell was -- the numeric tower is what prevented me from writing code in Haskell, right?  It was a very stupid thing.  I think if looking at the startup space, just being able to just go is huge.  Triability, so -- another one is observe ability, I think.  When I look at successes or if I look at the success of Scala.  Scala was this unknown thing until Twitter actually did it.  It's unclear how important it was to Twitter, but people all of a sudden had its stamp of approval it's a very big deal.  Go?  Well, Google uses go and it's used by these heroic programmers.  Great, so again, oh, yeah, sorry.
>>
AUDIENCE MEMBER:  [inaudible].
>>
>> So I believe the question was, it was a little faint, like my hearing is not so good.  I used to work at a radio station, so it's standing in front of speakers is not a good idea for prolonged periods of time.  I think the question was, a lot of languages are kind of -- could have different users and so how do we deal with that scenario in general?  And I think that when I was talking about niches, sort of the -- especially when starting out, finding a place where making a few people fanatical is kind of the -- like, appealing to everybody is hard, because everybody is -- on average, everybody is different.  And so but finding enough people who are similar and who will be fanatical and then growing from niche to niche is kind of a rough answer.  I'd love to talk more about that.  Front row?
>> .
AUDIENCE MEMBER:  Going back to like the same sex study where they found people who were sort of the center of communities and spread from there, did you notice in your research any instances of that kind of thing happening with programming language adopted?
>> Yes, yes, the question was so in the safe sex study, detecting community leaders was a big deal and that's how they kind of did this viral campaign effectively, and it's also -- there's a notion of people listen to -- you don't -- you listen to your friends and you listen to kind of like celebrities or you have influencers.  So I feel like cultive personalities are really strong here.  Maybe going back to that Twitter individual that maybe it's not individual but you have these high perceived organizations.  And kind of stupid you have the Rob Pikes who are actually a tiny part of the organization.  Somebody in the Google maps game, just one individual, getting them to be fanatical, just because one team is using it, Google is using it, right?  And probably should clear out after this, so one more.
>>
>> So were there differences between the subjective and the objective, like the reported and the actual -- there were a lot, but they're not coming to mind, so -- all right, great, all right, well, thank you.  So hopefully you've learned something here.
[break]


