Strangeloop 2014.

"PureScript (Maybe This Time We Get JavaScript Right)"

Presenter: Bodil Stokke

Live captioning by Norma Miller, whitecoatcaptioning.com

>> Good morning.  OK, yeah, I can hear myself now, much better.  Welcome to Strangeloop.  This is the first talk I'm actually able to pay attention to, on account of essentially having been writing my own talk up until this very point, so this is going to be very exciting.  I've got a lot of code in my slides that is supposed to work, and probably going to be a catastrophic failure, but that's half the fun of it, isn't it?  So I'm here to talk to you about PureScript, and I suppose, yeah, you know what?  Let's just get started.  Let's talk about Javascript.  Actually, let's not talk about Javascript.  I think at this point going on and going on about how frightfully awful Javascript is.  It's something that every growing functional programmer really wants to avoid, so we're all out there looking for alternatives, and that's certainly been my position on Javascript for at least the last five years.  Instead of going on on the horrors of Javascript, let me give you a brief summary.  It's a mess.  CMDR.  So anyway, let's talk about me.  People keep congratulating me for this picture, I'm not quite sure why.  Anyway, so since I was here at Strangeloop last, things have been happening in my life, so for one thing, I decided to move from Norway essentially where I used to live for the last many, many decades, Norway is -- this picture pretty much sums it up very neatly.  The weather is absolutely depressing and the music just to cope sort of goes beyond that.  Screaming your rage at existence and you have to scream about that much to actually cope with living in Norway.  I know what you're thinking, no, Alex, it's like this, right?  It's like, well, yeah, the summer in Norway is the most beautiful day of the year.  And sometimes something like this happens.  This is photoshopped, but for the most part it looks like this.  Literally.  The horse scenes from the empire strikes back were actually shot in Norway.  
     So I decided to finally come to my senses and moved to London.  Of course, I was gainfully employed at the time, so I needed to find another job in London to be able to do this.  And so as one does, one picks up one's electric telephone and one calls one's friend, the internet, and asks for advice, so that essentially, that is literally what I did, I asked on Twitter, "Does anyone have a job for me?"  
     And after talking to a few people, I ended up working for this little startup in Shoreditch, which I hate to say the word "advertising" but what they do is gamified advertising, and the idea is to put adds that are absolutely obnoxious, the initial product which caught my attention is they put tiny little games in place of captions very simple games like just drag this thing to here and you essentially and they were doing this essentially building the gales from scratch using jQuery every time, so it was obvious that what they needed was a game engine and that's been my project for the last year.  This wasn't supposed to be a commercial message just leading up to the fact that I've been building a game engine and let me show you the sort of game that we have built with this, the initial version of it, just to give you an idea.  So this is my demo game.  I've very carefully chosen a game with no branding, but some very, very good dogs, so the idea here of course is -- this is, well, I've ripped everything the graphic out of this game which is flapper dog which is essentially flapper bird, except with a better character.  This isn't, of course, the full game.  The idea is, as I said, just to drag this dog over to the pipes and drop them on the other side which completes the game, so let me try.  So very, very carefully, and whoops, that didn't work.  Let's try again.  So there we go.  So that's essentially the sort of game I've been writing an engine for.  
    I had a few ideas of how to do this.  For one thing int with ad it to be very, very functional.  At least if I because we're in Javascript, if I can't necessarily have those, at least I want to be not doing mutations of state, which we all know is very, very unfunctional.  And of course be writing everything in a functional style, as much as I can.  I also felt like -- I've been playing around with RSJX previously and I felt like it should be possible to just take this game logic and sort of squish it into a reactive stream that gets input from input devices, like the mouse drag and does something in between, and out the other end of the stream comes a description of what happens on the screen which you can just -- essentially, then, there's impure input and there's impure output because they have to actually run the physical world and everything in between should be as pure and referentially transparent as possible.  Eventually being functional.  And I felt like you should also be able to simply feed animations as reactive streams into the system and I've been using it a library which produces reactive streams which describes animations and infuse very neatly into the gaming function.  So when I was thinking about the design of this, I really thought I should have read this paper.  And there's somebody, I mean quite literally somebody who was on the stage right before me, who's had the same idea and actually built a language out of that.  But the other choice of course was to use Elm and if you didn't get an impression of Elm already from Evan, I'd like to describe it if Haskell were designed by a use ability expert.  Very intentionally designed to be user friendly is my impression of it.  Good God, that picture is truly disturbing.
>> But I had some constraints to deal with.  For one thing, as you're making this very complex little ads that have to be delivered very, very quickly, the size of the deliverable really, really matters, and Elm has -- well, a cost in that area, because there is a a not inconsiderable run size that has to go into the system.  It's not terrifyingly huge, but it's -- what was it?  About 100 kilobytes, that's still too much, sadly.  I also have to deal with very unpredictable environment.  It sort of makes assumptions that I can't afford to make.  I need to be able to work around things like your ads being embedded in pages developed by idiots that extent prototypes in very weird ways, so I need to be in complete control of the run type, which sadly, I mean I love Elm absolutely, it's been an inspiration throughout the process of building this, but sadly, I couldn't use it.
>> So I ended up having to use TypeScript instead.  Because TypeScript essentially, the TypeScript code is smaller in the sense that it essentially takes TypeScript, strips away the type anotations and produces Javascript, and the TypeScript is very, very tightly coupled to the resulting Javascript, but you get type checking for free.  TypeScript is not what I would describe as a very powerful type system.  I have I've been I've seen worse, I've been a java developer, but still it's a far cry from Haskell, let's say.  I did TypeScript, obviously, I use RXJS at first, but you remember the thing about the size constraint?  RXJS is big, so I ended up eventually going to bacon.  Bacon is not far behind, and it press compresses down to like 30 or 40 kilobytes.  So that was an idea, but I got along.  And we just essentially built the game that reactive stream that I described and feed it into rendering portion and it's pluggable so you can do if your browser just supports catalyst and so on, DOM is not great for mobile, but I actually built this entire game engine using the stack and there is working push that we are actually using in production now, but I mean throughout the process, I felt like, why couldn't this language be a little more like Haskell?  Because once you've done Haskell, you kind of miss the expressiveness of the type system or the crazy things that you can do with it.  And nothing ever really feels the same again.  Especially in the TypeScript.  And fortunately I wasn't only the only person to have this idea.  Essentially at the same time as I started development in this project, PureScript came along.  PureScript is implemented in Haskell currently.  There's work going on so you make PureScript in PureScript, currently implementation is in Haskell is essentially the selling point is it's it looks a lot like Haskell, it has most of the power of Haskell, but it sticks close to the Javascript and produces very, very neat Javascript code, and there's a little bit of a run-over, but it's negligible.  10 kilobytes or something, I can't remember.  PureScript is originally written by Phil Friedman but I couldn't find a high resolution image of Phil Friedman on the internet.  
     Let me go through the bullet points that made PureScript appeal to me.  It's got a Haskelly syntax, which is nice, it's very close to the Javascript.  It's actually pure.  Pure thing is not a joke.  The whole language is -- it's very -- a purely functional language.  Of course you have to manage effects in some way, so you've got an effect system that looks like the one in Idris.  You've got obviously a foreign function interface it's in Javascript which essentially lets you do anything you please.  There are a few functions that I thought were unsafe, but they essentially use the effort to escape.  I think of that as sort of a pragmatic choice.  Coming from Clojure, I have this idea that you try to stay pure for the most part, but if you absolutely have to do nicer things then you are able to do nicer things and in PureScript that happens through the FFI.  So I figured instead of gig you a point by point tutorial, I'll actually just show you some PureScript.  So this is my ruffle.  I wrote it yesterday.  It might or it might not work.  And our first exercise is it to show you some very, very basic PureScript.  If you know Haskell this is not going to look unusual to you.  
     Javascript arrays can be a little inefficient and these deal with them in a traditional Haskell way.  So one might want to create a data structure, this is called list of A, which means that the list contains values of Type A.  And one construct forker that is the cons constructer which takes another value of Type A and another list of Type A, and there's the list called nil.  I added an implementation of the show type class.  Yeah, how to summarize type classes?  Essentially they're like interfaces in java pretty much yeah, close enough.  Anyway, the show type class, you have to implement that to print the values on the screen.  So I've just prebuilt that.  Constructing a list.  Cons 1, cons 2, cons 3 nil.  
     Whoa, maybe I should go find it first.  That's essentially a cons list.  So great, a function for that, let's have a map function.  So of course this is a type language, we are going to have two type a and b and in PureScript you have to declare them unlike in Haskell.  I take from function from a to b and it takes a list of a and it returns a list of b, and if you map a function of the answer list, you get the empty list.  Actually we don't care about the function, so we replace it with an underscore which means I don't care.  And if you map it over doing pattern matching here on the cons constructer, so usually in Haskell it's tradition to go x and xs, I do I'm going to call it car and cdr, which I find much cleverer.  So that would be constructing a list with a had being confructose of f to a, and the recursive map, car and this one and the cdr.  So wonder if this works.  So let's take that list, map plus 1 over that.  And that gives us 2, 3, 4 nil.  Of course we've got the map function.  Of course with a that means is what sort of word from category theory could we choose from this?  It is a?
>> A functor, very good.  I'm going to provide an instance of the functor class for list.  It should be just functor list, where, and we have to implement the aptly named less than donor, greater than function and we have an implementation for that, it's map.  So it said now of map plus over the list plus we go plus 1, however you pronounce that functor properly, actually, I pronounce it map.  It's just a funny spelling.  So that should now do the same thing.  Whoo, we have implemented a functor, we are getting into category theory.
>> Ooh.  So I figured I'd dwell a little on the subject because it's my favorite subject ever.  Now, a lot of people already have already done the tutorial at this conference, so I'm not going to go into that, but I figured we'll be talking a little bit about my favorite thingy in category theory, so this is another data type which I've called pair.  In my game engine, the pair function is quite useful.  Think of it an an x and y function together.  The other xes together and the ys together and form new ones, so let's see if that works.  Pair 1, 2, if that works, add pairs, pair 1, 2,.
>> Yeah, so there seems an associative property, so what does that mean?  It forms a?  Patience, a gemmy group.  So instance semigroup pair, so in case you didn't catch that, if you have a data type and you have the ability to perform an associative binary operation on that data type, meaning, for instance, adding two numbers together, that counts.  That forms a semigroup.  So the rule is essentially, let me type it out for you if you've got a plus b plus c and it ecalls a plus b plus c with the parentheses like this, that means it has the associative property.  Now let's implement the semigroup.  The semigroup function is called less than greater than and we've implemented that with add pairs.  So now this forms a semigroup and of course the semigroup is generalized.  So you get just by implementing this type of instance, you get a little transitive for free.  Now, did somebody say monoid?  Let's see.  I like monoid, let's do one.  So that was a semigroup, and and that would just be monoid pair, so what's special about monoid?  Sorry?  I would go with the antivalue, actually, so anything that has the associative property is a semigroup and if there is also a value for which you can take any value and add that value, you get the original value unchanged, and effectively like this.  A plus empty equals a, if there is such a value, you have a monoid.  So m empty is what it's called.  What do you think?  Pair 00 obviously, so we're in categories there, this is fun.  So I need to import data monoid.  So now instead of pair 1, 2 now I can go pair 1, 2, m empty.  When I'm talking about M empty in this case I'm talking about the particular implementation for pairs because the other one is a pair, so this one has to be.  So that should get us what?
>> It should get us pair 1, 2, of course and indeed it does.  I'm much relieved to see this.  One more thing I want to see you before we get onto the game, so, stop doing that.  So I lost my semigroup and one of my definitions now but that's fine.  I don't think we need them.  Yes, we do, actually.  Semigroup.  Instance semigroup pair, semigroup pair where, this one is add pairs and that should do it.  Now, I want to show you quick check, because quick check is amazing.  So I've entered this -- oh, my God.  Yeah.  
     Oh, shit, OK, this is broken, so I wanted to show you how -- I can actually show you the code at least.  So this is an implementation of the arbitrary type class, which essentially provides a way to generate random values for pairs in this case, so you could write a function.  This isn't right, but I'm going to do it anyway.  Pair is semigroup, and the cool thing is I can just give a type signature it should give a response and quick check when I run it on this test is going to be able to understand that it needs to generate three values for pair and call this test for these random values and of course it does that in like 100 times and it's a very good way of checking.  So I'm going to do it, OK?  Semigroup, don't touch the mouse, is add pairs.  OK.  Now I'm able to actually call this function I've built called ver if I semigroup which essentially takes anything that forms a semigroup and runs tests to it to see if it meets the associative property.  So I run quick check, and quick check pure, 0 is the seeds.  100 is the number of times.  
     I'm totally not going to be able to finish my game now, but you see it runs as a test and they all seem to succeed.  We need a failing test.  And now you see it fails and now you actually see it's failing, it's telling you what's failed.  Now, sadly PureScript isn't doing this automatically.  This is my verified semigroup function, which is printing the input of the test that failed.  And you see there are also random values here.  So that was a very, very efficient way of writing test, wasn't it?  So generate your tests, don't write them.  All right, that was fun.  Now actually let's actually do something with it.  So I got 12 minutes left.  Let's see if we can build a game in that time.  I think I'm pushing it, but let's try.  So pushes I've got some prewritten code here, I've got a game ob type, which is a record which complies exactly to a Javascript object.  The record has a few themes, ID, CSS, these map directly to DOM IDs and process.  We've got coordinate, we've got base coordinate, we've got velocity, because these represent objects in the game and the objects can interact.  So essentially better be a rendering function for this.
>> See, and I've got this intersect function and I'm going to need and want to type that.  I'm going to show you -- let's get some -- why do you keep doing this?  Well, all right I guess we stick to the bottom now.  So I'm going to show you the FFI, because this render function just does a lot of things to the DOM and let's do that in Javascript.  And this is it, squished in.  So it takes for all e, this is it takes a game object, sorry about the and it returns an effect monoid, sorry I said the word, oh, my got, it returns the effect documentation, because here's a bit of polymorphism, it must have an DOM, but it can have loss of other effects, as well, and it returns unit, which means nothing.  So be lucky if I can even get the ground moving.  So the effect type, must return a function, so that should be this, ...  I wish it didn't keep sitting at the bottom so I can see what I'm doing.  OK.  Let's try and deal with T so the first thing we do is get the document elements by ID.  Object .id, which is with from the game object type.  Oh, I hate typing in these backslashes.  Cool.  OK.  We need to set the class.  And o.css, sorry, this is the most boring function in the whole game.  Of course, because it's Javascript.  Oh, this is so much typing.  I should have just left this in.  Now, for the css, we set left, class o. base x plus o.x floored, as and JK trick to turn a number into an integer ger.  Px,, top ...  Bear with me, please.  OK, and return nothing.  That should do it.  Last line?  Oh, yeah.  Thanks.  I did not see that.  OK.  So very quickly, now this is where I should have elaborated on how I have actually taken Evan's very lovely library and put it in PureScript.  Instead I'm just going to hurriedly type it out.  So we need a frame rate.  It takes a signal, that needs a number and we need a function that takes a number of milliseconds, and use the current type every 33 milliseconds in this case, that's going to give us a frame rate of about 25, 30 frames per second.  And the ground I'm going to use stream for that.  It's going to game object and we're going to start that off with a frame rate, and then sorry, this is -- this is the Mac function, actually, but got this very neat sin tox.  I could do it in the traditional Haskell way.  For some reason Evan didn't find that very reasonable.  Don't know what his problem is, but actually, -- so what I'm saying here is we've got a function y is going to be the number that comes out of frame rate, and we need a to create a game object, it's going to be called ground, and the css is going to be nothing special, x is going to be -- now, this is a computation I arrived at through science, which means trial and error, which is going to make the ground move in the way I want it to, multiplied by minus 8 and y should be 0, and the base x, that will be 0 position of the coordinate system place object is minus 128 and 384.  And I've got five minutes left.  Now we need a main function.  So this has to do with the M word.  You're going to be doing effective computation here so we're going to be doing this in the effect parameter as it's sometimes called.  So I go ground is the signal.  And I map a render of object function over it.  Now, oh, my God, it doesn't work.  It doesn't work.  Might have crashed.  It probably has, actually.  So I've got it on the clipboard.  I'm so nervous right now, I need to refresh the page.  Well, client connect please?  Oh, yeah, I have to do that.
>> OK.  It's moving.  Good ...
[applause] now let's see if we can do a pony in five minutes.  The pony should be jumping and first of all let's see we need the velocity function, going to be useful for all of them.  I'm just going to skip the tops.  Because I'm running so much out of time.  So it takes the game object and it modifies the game object with x should be ox plus ovx and y should be oy plus ovy, and that's essentially it, that's the velocity function.  And we need a gravity function, as well.  Which essentially it takes a game object and applies downwards gravity on it, so that means that the Vy is increased by what's gravity?  .98 Newtons, is it Newtons?  And so we need a pony.  Which pony should we go for?  Pink, yes, good choice, because it's the Om one I have graphic for.  And Pinkie needs a key stream as in input, because she's going to jump.  We're going to create a fold that is essentially we're going to have a function that modifies Pinkie for each frame.  And we're going to do that using the Pinkie logic function that we're going to implement.  I'm going to have an initial Pinkie value, and I'm going to map that over frame rate, key, which every particular frame rate, should give us whether or not the keys in the key stream will be pressed.  The key stream -- let's see let's go with a space bar.  So that's code 32 and the ground plan independent, let's go with another one.  P render object.  Let's define P as Pinkie over space bar.  So whew.  I think we're running out of time.  Let's see if we can get Pinkie rendering first.  I think I got carried away with the category theory, didn't I?  Where are we Pinkie?  Pinkie logic.  Takes a space bar and it takes a Pinkie and we apply gravity, and we apply velocity and wow, it's crashed again, so here we go, this is scary.  Refresh.  OK you know what, since we are out of time, I actually realized I have a copy of this game that's complete, that's going to be very unexciting for you, I think you'd rather have lunch to be honest, so very quickly running through, so Pinkie, I wish this scrolled better, so essentially the Pinkie logic function I will explain it now, I missed that joke, sorry, actually forced through the ground because of gravity and I haven't made the ground solid and so I've ground function and I implemented jump, and they are quite simply replaceable functions from game object to game object so this is very neat and pure and functional.  So the jump function and here's initial Pinkie, yes and I've also got this coin logic.  Simply just moves from offscreen and loops back and if she jumps and touches it, you see core.logic has this very neat pattern where if you intersect with pinkie, whose stream I'm actually having to feed into the coin stream, because the coin has reactive thinking so it needs to know where she is.  And I put I don't know on the screen and I put Pinkie on the screen and let's see if it works.  She can jump as you can see.  And she can get the coins.  And --
[applause] -- and that was not very much PureScript at all, was it?  And I got the this is what happens when you write your own, but you know, at least then you know that you were using it before it was cool.  This is all the code you write for a game and apart from this ugly bit of Javascript here, this is all purely functional, which is pretty cool.  And enough of that.  I won't keep you from lunch.  Hello Pinkie.  OK.  So that was it.  Now, before we go, I usually put links to my slides here, but as you can see, I need to get the bugs out first and I'm also just about to publish the signal library and some of the other things that I've been building on the side towards this game engine.  I'm actually going to publish the game engine itself, but I wouldn't hold my breath for that.  It needs a little more thinking, so but thank you very, very much.  I hope it at least piqued your interest in PureScript and yeah, go have lunch please.  I'm sure there's absolutely no time for questions.  Go.
[break]



>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>> 
