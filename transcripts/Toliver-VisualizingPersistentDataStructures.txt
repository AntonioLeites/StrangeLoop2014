Strangeloop 2014

"Persistent Data Structures"
Presenter:  Dann Toliver.

Live captioning by Norma Miller, whitecoatcaptioning.com

>> DANN TOLIVER:  Hasn't this been an amazing week?  This is incredible, right?  I love Strangeloop.  That's not just a cheap way to get applause at the beginning of a talk.  I really do love it here.  I spoke here last year, actually, it was the second talk of the preconference so by a strange twist of scheduling symmetry, I'm now one of the penultimate talks of the conference so unlike last year when I was getting everyone excited and had a bunch of eager open minds awaiting what I was if to say, this year my job more like pouring out a cup of water on an overflowing barrel and if your week has been like mine then your head is pretty full.  I'm going to talk to you a little bit about date structures, which as it turns out are quite complicated.  We'll see maybe a couple of ways of making them simpler and more relatable and getting a more intuitive understanding of what's going on an and then we'll look at some pretty pictures for the rest of the talk or at least some pictures.  So I said data structures are complicated.  A lot of that complexity is accidental complexity.  You probably all know the difference between accidental complexity which is kind of unnecessary and inherent complexity and I figured you did so the quotes up there aren't actually because I'm introducing a new term.  Those are actually scare quotes.  While I was researching this talk, I uncovered evidence of a vast international conspiracy.  Going back decades.  Whose sole purpose seems to be to obfuscate data structures and their terminology, so that folks like you and I won't be able to understand that.
>> So I'll give you an example of that.  One, you know, easy breakdown in data structures is between abstract data structures which are an API which is just a list of operations like a protocol or a type class or abstract class and the implementation and we would never confuse the API with the implementation, we just wouldn't do that.  So let's see how wefare with the data structures by playing a little game I like to call abstract or concrete.  I've given them to over 100 developers.  Every one of them have gotten at least one of them wrong and several of them have gotten them all wrong.
>> So here we go.  How about a stack, is that abstract?  OK, is that concrete?  OK, good.  So that is abstract.  It's two operation, push and pop, we need both of those operations to be a stack and we've got different implementations that can fulfill that so let the record show it was maybe an 80/20 split.  Actually gets' get a baseline.  Who knows what a persistent data structure is.  OK, wow, a lot of you that's great.  Maybe I can speed through those slides.  And who has heard the phrase data structure before.  Good.  OK.  So we're at about 90% of you are playing along.  That's excellent.  So how about a link list?  Is that abstract or is that concrete?
>> OK.  That is concrete.  It defines an actual in-memory structure for the data.  It has performance implications.  But it also gives us operations that can fulfill different APIs, so how about a queue?  Is that abstract?  Or is a queue concrete?
>>
>> OK.  So yes, a queue is abstract.  You're catching on.  This is excellent.  How about a list?  A plain old list.  Is that abstract?  Or is that concrete?  Yeah, so a list is abstract.  It defines a few operations.  So how about an array?  Is that abstract?
>>
>> A few of you.  Is that concrete?  Many more of you an array is actually both.  So you're all wrong.
>> An array is essentially a list with random access on it.  Random access operation, and it's also the data structure that fulfills it, so this is yet another way that they are working very hard to confuse you.  There's a whole bunch more of these, I'm going to skip through those now in the interest of time but this is a really fun party game that you can play with your friends and it gets harder later on.  So let me give you some rules of thumb to distinguish between these two.  Generic terms are abstract.  Except there are some irregular cases, these are not all of them.  You just have to memorize them, I'm sorry.  So if you have adjectives that tends to imply that you're dealing with a concrete structure, unless you have too many adjectives, such as a self-balancing binary search tree.  Think for a minute whether that's abstract or concrete.  Or you have too few adjectives, right?  Priority queue is it a particularly nasty one.  The most common implementation of this is a heap which sounds like it should be abstract so people use the term heap mean priority queue and they use priority queue to mean heap.  I mean they are wrong but om wrong but these are different things.
>> If it has the creator's name it is definitely concrete.  There are no exceptions.  Always.  In fact, we can say if it's got a proper name at all it's concrete.  Even if that proper name is a historical figure or a -- I haven't looked up there yet, there's supposed to be more of a margin on the side, but that's OK, my slides are not beautiful anyway, if it's a historical figure or it happens to be the inventer's daughter or it's just an acronym that isn't even a proper name at all but happens to be Patricia, then it's concrete, no sessions.  None.
>> Right, so self-balancing binary search tree.  Data structures form these families of refinement and over time.  If the root who pronounces trie "tree"?  "Try" is a much better way.  Does anybody pronounce it tree with an I with finger quotes?  That's just me.
>> If your root word is concrete, then you're in luck because any time you're talking about a trie it's concrete.  If it's neither concrete nor abstract, then you're in trouble, because you might be talking about one of the particular implementations in this collection or you may be talking about the entire collection or you may be talking about the API that you've abstracted from the operations that are common among the elements of the collection, and so the answer to is it abstract or concrete is just complicated.  It on the context.
>> Persistent or ephemeral?  Ephemeral data structure is just a moment in time.  I think I have time to give you my Lego example, OK, so if you buy a set of Legos and you build a Lego castle then at the end you've got a Lego castle and you don't know anything about its past, you just know what it is in the moment and it's a perfectly fine Lego castle.  If you buy a bunch much sets of Legos and on the first one you take out one Lego and put it on one pedestal and in the second box you take out two Legos and the third one when you get to the end you've got the Lego castle and you've got all of the history laid out.  That's a persistent data structure.  Now, this is an incredibly expensive way.  So you have the space and time issues expenses.  But we can actually do better than that.  We don't have to deal with regular Legos, we can use magical Legos, and there's one weird trick that you need to know that lets you get from regular Legos to magical Legos and I'll show you that this in a in a moment.  We can actually improve on this.  So here we are's introducing a are bit of 690 surfer slang I'm fully stoked.  I'm fully persistent.  I was going to do a surfer accent but I tried it and it was just terrible.  So with a fully persistent data system we can take any object in our history and build on it.  So we can not only read on our history, we can also take an item from it and begin building on it.  Another way of thinking about this is we can all get our Lego castle and we start building on it, right?  And if I happen to see your Lego castle and I like it more than mine, I can chuck mine and grab yours and use it instead of mine and that's a very nice property to have and we can do this with our one weird trick by sharing the base Legos that I can use and I can copy yours without actually paying the expense of it.
>> So now our conspiracy is back to its old tricks, they're introducing archaic English, the word confluence of course is where two rivers meet.  It just means that we can take one of those branches and merge it back in.  So if I like your Lego structure better than I like my Lego castle but I like some of the features of my Look Lego castle, I don't have to throw it away.  I can merge it with your Lego castle.  That's a wonderful property to have.  So what does this remind you of?  Git, yes, so the next time you're at a party and somebody is talking about confluently persistent data structures, and say oh, you mean like git?  Hilarity will ensue.  In fact, you can walk away and come back 20 minutes later and they will still be going on about it.  So here's our one weird trick, we'll make a tree.  What we want is a list of numbers, for example, but if we have a will list of numbers and we want to change one of those, then we have to copy the entire list of numbers and put our change list in in order to have persistence.  We've just got regular Legos, if we make a tree out of it by chopping up that list into smaller lists that point to each other or maybe we can make a trie and put all the values at the bottom, then we can do this thing where we walk down the tree, make a little copy of just the sublist down here and then make pointers back up that take only log-in time and log in extra space to give you persistence.  This is amazing.  As it turns out trees are also really nice for parallelism.  Guy Steele gave a nice talk a few years ago here.  I suggest you watch it it's really good.  So we've got consequences for being concrete, time consequence, space consequence was, space-time implication, there's a whole bunch of stuff in here.  This is a tiny slice of pa tiny slice of the data structures, right?  I mean you're not supposed to be able to read this but you're essentially comparing operations on one axis to data structures, computations on another axis and then you're in theory going off in a third dimension of looking at all the different performance and spatial implications.  This is terrible, right?  How do we make this relatable?  I'm staring at this mountain of data, and suddenly it hits me:  Baseball.  Baseball is the answer.  So this is from a newspaper 100 years ago, they had the same problem.  This is one game, right?  One game between two teams in a season that had I don't know, hundreds of games.  What's an order of magnitude estimate for games -- 162, thank you.  So imagine this times 162, times various seasons, with actually a lot more stats in there, right?  So how do we make this relatable?  Well, obviously we make baseball cards out of it, right?  So I suggest to you that the answer here is to make data structures relatable is to make data structure cards.
>> Now, this is my original implementation in photo shop and comic Sans.  My partner in crime Henry fabber was reviewing my slides late last night and ests like, no, no, no, I'm not going to let you burn their eyeballs out so he reimplemented this in a much nicer form using the premiere 21st Century typing tool, omnigraphal.  So here we have our stack.  And we can see that indeed a link list makes a really good stack.  It's got fast push and popup actions which is exactly what we want.  So what if we take a queue and compare that to a link list, what do if we get and that's not so good anymore.
>> So you can see these things emerge in game cards.  In this case it's going to be quite dire if you have a fully persistent link list, so maybe you'll miss two turns if you have a tail pointer and you allow a mutation, then you lose your persistence but you gain the ability to fulfill this quickly but that's a different.  That's part of the expansion pack.  So we could have a AA link list that but it's ephemeral.  I sent Henry the text for these, also very late last night.  Ephemeral and it mutates, which probably causes some type of an effect in the game that we're imagining.  But it makes a dandy queue.  So if you can handle those properties, then this is a great way to go.  Here's a batched queue which is a nice way of doing a queue persistently, and I want you to remember this one.  Most of the others you can kind of let slide by.  Keep this in your head.  We're going to have two stacks we're going to push off one stack and pop off the other stack:  And then we'll just reverse it and that will be our new pop stack and get the other a push stack.  Raise your hand if you're familiar with this already.  OK, raise your hand if you're not familiar with this hand my explanation made sense.  OK, good.  That's much better than I expected actually.  Great.  So we've got some nice properties here we're amour advertised and -- that's not a mass property, actually, we've got a bad property which means we're amortized and every now and then we're going to have to do this big shifting operation but if you think about an item going in it undergoes four operations.  It gets pushed, it gets popped, it gets pushed again and it gets popped again.  So we're amortized which means we're occasionally going to have to pay a big cost at a sudden moment so we have this if you're doing a realtime system something like that.  If you're staying around for Racketcon they've got about 12 versions of this physicists queue banker's queue, maybe an astronaut queue, I don't know, there's all kinds of them.  So this is a deque which confusingly often has a U and an E on the understand of it so it's DQ which is one of the other operations you can do on a deque but some smart person decided to DQQ on the end of it and this is another example of the ambiguity.  How do we get a deque that's persistent?  So I was going to talk about two-three finger trees which make dandy deques, I'm going to skip ahead and show you what a terrible hash I made of this a trie means we've got everything down at the bottom.  In this case we're you can with aing down with sections of the key so we take five bits of the key that we're looking for after hashing it.  And we take the first five bits of that hash and we look at where to go from there.  So that five bits gives you an array of 32.  I'm saying a lot of words without really explaining them very well.  Here are the things I want you to remember:  They're very useful data structures and they involve arrays of.  5 out of 32.  So keep those I'm at 20 minutes now and usually when I practice this I've been at 40 minutes now so this gives us much more time for the next section which I'm excited about.  So the question is it, I've shown you a whole bunch of different data structures.  And maybe some ways to think about them and classify them and get a little more -- make them a little more relatable, but how do we -- how do we deal with the data that's already in our systems.  One way to do that is to you know, take a snapshot of that data every now and then and dig through it and try to figure out what they're doing.  Another way to do it is to look at the code.  So you go in the code and you try to figure out what they're doing with this data structure and what the properties are.  So I'm going to show you a different way of doing that and we'll be doing it in Javascript which has some produces and cons.  Let's see, can you see this?  Is that visible?  I bet you can see that, OK.  All right.  So let's say we've got a really simple data thing.  This is just an array of size 3.  And we'd like to render that.  So what are we looking at over here?  This is -- let's actually make X bigger.  We're going to take some sequential numbers, we'll take 88 of them, 88 of them, and we'll render that.  So a render is really simple, it's just a pipeline that kind of flattens things, and then it colorizes them, evals them and then colorizes them, and then kind of pushes them up here.  So here are the important parts that you need to know for this right now.  We're going to display colors based on their that correlate to these values.  One is up here, it's 1 and 88 is down here, it's green, and there's a black bit on either side and that's because when we flatten these things 0 out we want to be able to see what's inside of them in terms of their kind of steps that we're taking up and down.  So we're going to color those as well.  We're going to color them black.  So here we've got a bunch much black dots because we're kind of walking up and down.  OK.  So what if we make a Y and we'll fill it with some random numbers, because that will be fun.  And then we're just going to say array dot observe, and we're going to ask our browser to observe Y, and we'll feed it a function, which is just render Y.  This almost fits on the screen.  Oh, I got it right.  OK.  And now we can say Y push and we'll just push around a number into it, and we'll do that a couple of more times, and then we will say Y shift and pop something off.  And so we can actually as we're mutating Y, we're in mutational mode, we're watching it happen on the screen.  So what if we combine these two operations together and we push in a random number and we also shift off so this is what it ends up looking like.  You can see down here at the bottom, maybe I'll do this a few more times, actually this is really annoying, so we'll do this instead, good.  OK.  So as I push this magical button that I just created, you can see items going in on the bottom, that's the new colors that are appearing and items going off the top, and you can tell that it's working as a queue because it doesn't increase in size, it's just fixed.  Does everyone understand that?  OK.  I think I've belabored that enough.
>> Let's look at a slightly more interesting example.  This is that simple queue that we just saw.  This is a trickier queue.  It's working as a queue, but there's some weird stuff happening in there.  So let's see if we can figure out what the algorithm for tricky queue is just by looking at this visualization, OK?  So the first thing that we notice is it is in fact a queue, it is not increasing in size.  We've got new stuff coming in at the bottom and stuff leaving at the top.  So far so good it's exactly like our queue, but then we've got these spans like here, can you see the pointer OK, the mouse?  Yeah?  OK.  We've got these spans like this first one here, where nothing is happening, almost nothing is happening.  So we must not be pushing or popping at that point.  And we've got these red things appearing here, so I guess every once in a while we're pushing a particular value in at this particular level.
>> Maybe this is 20 pixels in.  I've zoomed the pixels out so they're like 5 by 5 squares, jut for this part of the demonstration, and then we've got the same thing happening down here with the blue.  We're pushing something in there.  Does that make sense?
>>
>> OK.  What if I push this button?  What happens there?
>> Well, we've got these purple things appearing and they seem to appear fairly regularly.  So I must be pushing some values in every I don't know, 10 values or something.  OK.  So maybe we've -- so I actually know what this algorithm is since I wrote it and that's exactly what it is.  Now let's look at something that I haven't looked at the code for, didn't write and haven't looked at the data of.  There are two different persistent data structure libraries for Javascript, there's actually a lot of them, but a classic one is Mori and a new one is Facebook's immutable JS so I want to look at some pick towers and see if we can get some insight.  We'll play through this queue a bit and then we'll stop it and see if we can figure out what's going on.  OK, so the first thing we notice is these black bars here.  And then here we start popping them off.  So we're populating the queue and we're popping things off.  This is not really a queue it's a vector but I'm using it as a queue.  So we notice this banding here with these thick black bars, this seems to indicate that we've got these 32 arrays.  We also have these darker areas here, and the darker areas indicate that we've stepped down a level, so these things are happening further down in our data structure tree than these things.  And we can see that we kind of accumulate into one of these, and then we place it over here.  Which is pop it up a level.  So this must be some kind of tail that they're using as an accumulator and then when it gets to size 32, we pop that up here.  We also have this other interesting feature.  Which is this bar at the top, and all four of these, four or five of these pixels has the same -- oh, except this bottom one so I don't know if if you can see this but there's a solid color line here which is some type of meta data that isn't changing and everything else starts off at the same value so we'll guess that's 0 and then it flows through so we're increasing increasing and suddenly we switch over and this one cuts back to maybe 0 and then these two start doing something else.  I've stared at these a lot longer than you have, so I'm giving you a guided tour, but hopefully this is making a little bit of sense and then this weird jaggediness down here * correlates with two things.  One is this little bump when we run out of one of our buckets here, then we make a jump, so we run out of the bucket here and we have our new tame starting here.  This is our new full bucket.  We can see the tails are still a little darker down here and then we start a new tail but just after we start that, we were shifting up here.  I want to show you one more feature and then we'll look at Mori's version which is this little tiny bump here.  And it seems like a glitch.  Essential we we're pushing this new color this but up here we're not popping anything off.  So what is going on there it seems that something has gone awry that every single time I have run this it's doing this.  I don't know why.  There's something interesting happening maybe 8 steps in to using this as a queue after we stop popping and I'd love to know what that is.  All right, so let's look at Mori's version.  Pretty much the same.  We've got a little bit more meta data up here and then oh, dear so that's a lot different.  That's my alarm telling me that I should have moved on to this point by now, which I have so that's good.
>> OK, so oh, does that affect?  No it doesn't.  It's om for me.  But it makes me happier.  OK, so we've got some meta data here, and that doesn't seem to ever change, OK?  That's fine.  We've got a bunch more meta data up here.  Otherwise, this seems to be more or less the same as the Facebook version that we were seeing, but then something really weird happens, so right here is where we start popping.  I happen to know that because we're popping at the same point as the Facebook one which is like 200 values or something.  And as soon as we start popping, we get this really weird effect where this part of the data structure is now here, but we're not actually popping anything off.  And then we've got this other part of the data structure that's accumulating things, so what does this remind you of?  A batched queue, right?  We looked at a data structure that worked as a queue that used two stacks, and so we're building up one thing here, and then as soon as we start popping, that thing goes here.  Nothing comes off of it oddly enough, and then we start building up a second thing.  And then something weird happens here, and then we start building up another thing and it looks like, if we look at these colors, that this actually pops up here at this point.  So we've got some other strange features, this looks like -- I don't know, is that meta data or is that a copy of something?  It's hard to tell.  But we have a' got this weird area in the middle.  Some of the meta data from up here seems to move down to here.  So that's fine.  We won't worry about that.  It looks like it's size information that's increasing.  So what is this middle chunk?  Well, this is exactly this.  And this is exactly this.  So these are pointers, they're shaded a little bit, they're darker because they're one level down in the tree than this stuff that they're pointing to, so what it looks like is happening we're taking a bucket here and putting a point here and probably this is 32 across and 32 high so we're popping things off and we're doing that again and doing that again and then when we run out, we have this strange effect where like our last little -- oh, I see that's what this is.  This is the previous tail that's left over here getting copied up here.  I didn't actually know that.  So here's our little tail bit and so that's why this chunk is shifted up, and then when we're done we just throw away the entire thing, right?  So this is actually really nice, because this in some ways has some garbage collection implications where we're collecting each of these buckets every time we get done with them.  Here we're only collecting the buckets once, when that entire stack is it done.  And we just collect it all at once, right?  Instead of popping things off.  This is probably because in Javascript, shifting things off is a really expensive operation.
>> OK.  Is this making sense?
>>
>> Kind of?Ish?  All right.  Let's look at maps.  So here's a random map in the Facebook system without the black bars.  And here's the same map in the Mori system and these little pretty similar.  Like this one is growing a little more slowly but it's going to be hard to tell the difference between them.  It looks like this data and this data maybe correlate somehow, maybe this is meta data because it's all one color, I don't know.  Let's look at these with the black bars on.  (Whistles) that's growing really fast.  OK, let's look at Mori with the black bars on.  It doesn't necessary did I -- oh, that's interesting we've got this jump here that clearly indicates that after we get to I don't know, maybe that's 32 then we jump and do something different so the facts that this one grows so quickly in our picture doesn't mean that we're using more space because we're only showing numbers and.  But they are definitely different data structures, this one seems to be using other old friend ham team.  And this one I don't know what it is.  There's lots of other subobjects in here.  Let's look at this sequentially.  So before I was just inserting random numbers, the keys are strings, so the number with a letter appended.  Now we're putting numbers in sequentially and we see really distinct banding patterns happening.  So we can get a few things, one, we can get that this is the data in this middle section, and that the data is being hashed in some curious fashion, that keeps changing over time.  We've got a lot of meta data up here.  If we turn on the black bars what will happen?  So let's see Mori sequentially adding things.  We've got our -- but we're growing in a much different fashion, right so whereas these are clearly banded and you can see they're using a modular operation for the hash of some kind, here we're growing in an entirely different fashion.
>> And it looks like, I don't know, oop then we're starting to get some banding where we skip around.  Let's turn on the black bars for a moment.  And we see we've got these big wide data containers, this is probably our hasher and map tree at these boundary points having new elements added to it and if we try this one sequentially again, then we would slow down my computer a lot, and get just this very linear progression, because none of this is changing at all.  So I can't tell you exactly what the implementations are under the hood, but we can already tell a lot about these data structures just from looking at these pictures that are being generated in an incredibly simplistic fashion.  Really in some ways the most simplistic:  It's we're just flats eng things down and then throwing it up there based on value * but we don't have to do that.  We could show a difference between the previous state and this state.  We could take into account data locality.  We could so a discrete area platform over the data that we're sending.  So we can see how frequent the updates of the data are structure are.  If you had this running in a realtime application I think that would be quite.  :  But in your language of choice you could do it this and peek inside your running systems and actually see what's going on inside them at a level that I think would be really interesting to explore.  So back to the slides.
>> Count to three while this slowly does its thing.  OK, remember your rules of thumb.  They're very helpful for parties.  Data structure cards, very exciting, and visualize your data, because you never know what you're going to find.  All right, I'm done.  I think I've exhausted all my time so I'll take questions offline.  Thank you.
>> I shouldsay, this is all open source, you can find it on my GitHub account if you would like to use it.
[break]

