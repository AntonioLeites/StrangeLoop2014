Strangeloop 2014      

Keynote:  "Inside the Wolfram Language"

Live Captioning by Norma Miller, whitecoatcaptioning.com

   ALEX:  Welcome, everyone.  I hope you had a good day at Strangeloop today.
[applause]
>> I wanted to mention a few, just a few defails.  If you parked over at the Union Station lot and need a parking voucher, make sure you grab one at on your way out.  The unsessions are tonight 7 to 10, and if you're staying at the Hilton and attending the unsessions, there's a shuttle running from 8:30 to 10:30 to help you get back.  And earlier this morning I talked about our diversity scholarship program and some of the things we did this year. I missed one thing and I really wanted to thank Bridget Hillyer, who's helped tremendously all year long to help focus those efforts, so a big thank you to her, please.  And I would like to announce our keynote speaker for today.  He is ...
Stephen Wolfram.
>>
>> STEPHEN WOLFRAM:  Thanks. OK, well, I'm going to talk about a few things.  I'm going to talk about some things that I've kind of been working on for about 35 years now that are finally coming to fruition in these months, and I'm also -- just because I live off of these kinds of things, I'm going to get to show you some stuff that just went live about 15 minutes ago, that we'll see whether it works.  The thing I most want to talk about is the Wolfram language.  It's something that I've been progressively building for about 35 years.  It's a programming language, new kind of programming language in many ways.  It's sort of emerged from what I've done with Mathematica and with Wolfram/Alpha, to some extent with things I've done with a new kind of science and, it's also come about because of a bunch of new things that we figured out in the last few years.
>> So Mathematica, as many of you may know, is a computation system that we released actually 26 years ago now that's very widely used in R & D groups around the world and in universities and in those kinds of places.  Wolfram/Alpha one of the components that's allowed us to build the Wolfram language we released about five years ago now.  
     Its goal is to take random questions people ask it -- oh, come on, yes, let's ask it a random question.  Let me see if I can make this -- there we go -- and try to answer them.  And it answers some of those questions on the web, it answers some of those questions through intelligent assistance like Siri and so on, and its goal is to, as I say, take natural language and use -- if we can connect to the web.  If we can't connect to the web, this is not going to be much fun.  
     OK.  There we go, at least.  So the idea of Wolfram/Alpha.  If there's a question that can in principle be answered on the basis of knowledge that's sort of been accumulated in the world that we've been able to curate and make computable, have it be automatic to have that question answered by the system.  So if we say something like, you know, what is the population of St. Louis, we should, if we can connect to the web, we should be able to get some answer.  
     The goal is to kind of give a report that tells us something about -- sort of contextualizes the answer here.  So we've got some data, OK, this is so we can say what's the population of St. Louis divided by Chicago.  That's something that we as humans can understand, so can our natural language understanding stack and give us a result.  We could ask it all kinds of things, there's all kinds of data that comes in.  Typically what happens is there's raw data, and on top of that data, one builds up a collection of models and algorithms and so on that allows it to compute answers to things that people want to know.  So there's a feed that tells where all the various satellites all around the world are, and from that feed we can work out that St. Louis, it's not visible, it will rise at, or we can type in all sorts of things here.  We can type some random sequence like this, and we might be able to figure as humans that it's a genome sequence.  It will try and look up that on the human genome.  The expected number of answers on the human genome is zero, but in fact, oh, there's one, that's cool.  
    It's -- so all this knowledge that we've been accumulating in Wolfram/Alpha and there's a lot about it in thousands of different domains, this is all knowledge that we've been sort of ingesting, putting on our service, curating.  All of this knowledge is one of the components that goes into Wolfram language.  
     So let me show you the Wolfram language.  I'm show it to you here on the desktop.  There's also a version that's purely in the cloud that just runs in a web browser that I could also show you, but let me show you the desktop version.  Is that large enough, or is that way too small?  Small?  It's too small, OK, how about that?  Yes?  Yes, OK.  Good.  
     All right, let's see if it's, working.  OK, that's a good sign.  So let's say we can do all kinds of computations here, so there's the result.  Let's say, I don't know, we've got a whole bunch much digits there.  Let's just for fun let's give it a few more digits.  Let's say this.  Let's say we want to do some analysis, let's treat that as data, so let's say what are the integer digits of that data.  Let's for example say let's make a histogram of which digit is most common?  OK, there's the results.  Maybe we could go ahead and let's make a histogram -- let's do this:  Let's say we take the digits -- OK, so what did we have?  We had integer digits of 1234 to the power -- let's say 1230 plus n, for example.  Let's say we wanted to make a histogram of that and we wanted to make a little interactive application that works out these histograms, so let's say we say manipulate that with n going to zero to, I don't know, 50 in steps of 1.  Now what we should have here is some kind of little interactive histogram that just shows us the different results for different powers there.  Maybe it would be easier if we just take this and just make a table here of values for n goes to let's say from 0 to 5 or something, and that will give us a bunch of little graphics there.  And maybe we want some -- let's say we want this to be something that's suitable for putting on the web or something, let's say we could say, you know, use a plot theme that is appropriate for the web.  OK, I just made 2 slightly brighter and made the axes simpler.  OK, so the general idea of the Wolfram language is to put as much knowledge and as much automation about that knowledge as possible right into the language.  Most knowledge.  Let's let all sorts of random people build up libraries based on that language.  
     My idea about Wolfram is let's make the language as big as possible.  That puts a huge burden on the language developer which ultimately has been me for three decades or so.  Because that means its up to the language developer and by now there are about 5,000 built in functions in the Wolfram language covering all kinds of different things.  So let's -- we can just to get some sense of what's there, this is kind of the sort of the big outline of the kinds of things that are there.  But let me show you some more specifics of kinds of things you can do.  So let's say, I don't know, we could pull in, let's say we pull in data from my Facebook friend graph, and actually I will not tempt fate by doing the real thing.  Let me simulate my Facebook friend graph.  There's a pretty good simulation.  That's a graph with 100 nodes, 200 edges, random graph, let's take that graph, OK we'll pick up the graph and let's say let's make a community graph plot of that graph showing the communities that exist within that graph.  So there we have it.  We could go ahead, we can deal with all kinds of things in the Wolfram language, so let's say -- for example, let's pick up a current image.  Very dark, let's try it again.  There we go.  OK, lousy image, but let's take that image and let's say for example let's take that image, we say edge detect.  Let's take the image there.  There's an edge detect of that image and maybe I can go ahead and say dynamically edge detect the current image, and then I should get something which interactively lets me wave around and detecting.
>>
[applause]
>> We can take -- actually, let's take this one.  OK, people like that, all right.  So let's take this guy and -- let's start trying to do a little bit of coding here.  Let's break this image into little blocks, now we can do something like, what can we do with these blocks?  Let's do -- let's say -- let's image rotate by -- how about we do this, let's do image reflect onto those blocks, level 2 there, so I've seen each little block in there and I've flipped it, I've reflected it so it's let's assemble that again.  OK, that's a little weird.
>> we could do that in real time if we want to.  I mean we could go ahead and just say, let's pick that whole thing up and let's just put in a current image there, and let's say image assemble here, and then let's -- whoops, image assemble there and let's say we want to make that dynamic, -- I think this will work, we'll see.  And oop, what did I just do wrong?  I did not tell it -- but it's very beautifully dynamically and having that picture go there.  What did I do wrong?  Oh, partition it, yes, very good.  That was hopeless.  Let's -- without that -- see, this is the problem, this is the disease of somebody like me that I make these things up and -- OK.  No, it works well.
>> so let's try -- this is good, yes.  I should -- all right, we better kill that off.  It's looking too goofy there.  Whoops, what did I do?  I should -- I just -- wow, let's just kill that one off it's going to distract me to no end.  Let's try something else.  How about we try making a bunch of random integers that say integers minus one to one, to make 100 integers, and let's take those random p integers, let's accumulate so we're making cumulative sums of those integers, OK, we get the result.  Let's take that and let's make those into notes, sound notes.  Try taking this.  And then let's say make a sound out of that.  See what happens if I do this.  OK.
>> OK.  Wasn't that exciting, but we can, maybe we can try -- let's say -- let's try doing that.  Let's make it a tiny little bit longer.
>> OK, so we can deal with all kinds of things, whether it's networks or images or sounds, we can do image processing, signal processing, all those kinds of things.  One of the things that's a really important feature of the Wolfram language is that it also deals with things about the real world.  So if I say here, here is a geo position.  If I say sunset, it knows about sunset at this geo position, so for example, I could say something like, you know, sunset tomorrow, minus sunset today, and that's probably going to be -- oh, it's very close to 1 day, right?  And of course it knows about units and things so it can figure out what that is in terms of if I say minus -- let's do this, minus one day here, then it will go ahead and tell us some -- tell us that.  We can also -- so one thing we're doing here is using natural language as a way to input sort of a specification of things in the world, so for example, let's say I say planets, OK, that's an entity that represents planets, so I could say, let's give me an entity list, OK, so this will now be a list of entities that correspond to planets and so for example I could say something like entity value, associated with those of image, and now I should get images of the various planets.  OK?  There we go.  And now for example, let's say I could take -- let's say I could go back to this list of planets here and I could say something like -- let's put these all together, so let's take these, it's a list of planets, OK, so we've got entity, entity value of that, image.  B. well, actually let's do another entity value, let's say that, mass.  So there's the masses of the planets.  Let's go ahead and get the list of images of the planets and now let's try and take, OK we've got those two together and now let's take the last two, % means the last line, double% actually means the line before that.  It's actually very, very bad practice to use % and so on, because it doesn't make for beautifully, there are better things you can do if you actually write in code, but I'm being fast here, so I'm going to do that.  So this made an image collage out of the pictures of the planets with the size of each planet corresponding to being determined by the mass that we had computed for those planets.  So that's kind of nice.  So we're now going to load in a bunch of data about movies from our knowledge base and let's try taking a -- I just tried actually something like this.  I was showing people this, let's try something like this, let's try taking 50 random movies and then let's -- OK, there we go.  OK, wake up.  Hopefully this will work.  Let's try and get 50 random movies.
>> Each movie is represented as kind of an entity and let me say I would say entity value of that, image.  And let me say delete missing and that will get rid of ones where there isn't an image associated with that movie.  This should get us the posters for those movies.  OK, so there's 50.  Well, some number of random movie posters and now we could say something like we could say dominant colors associated with those movie posters, so this is now doing some image analysis of each of those movie posters to try to figure out dominant colors OK, there we go.  And then we can make a chromaticity plot of those colors and we can will see the clustering of the movie posters on the chromaticity program.  If we went to a little more effort we could go to the release dates or the box office returns of those movies and compare them with the colors we used for the posters and see whether it's going to have a green poster or something.  So we know about all kinds of things.  
    Let's try something else.  Let's say we want to do something with geography, so this will give us some based on where it thinks we are from other geo IP location, this will give us some graphics, how about we do, let's do something like the Eiffel Tower, OK, so that's an entity for us, and this will be graphics, a map showing region around the Eiffel Tower, hopefully, and come on, wake up, there we go, so there's a picture of Paris, so now what we could do, maybe we could make a disc around the Eiffel tower and let's make that disc be a radius which is -- let's try doing this, let's say its radius of let's make one of those powers of ten type things.  So we'll say it's 10 to the n mile radius disc and yes, there we go.  OK.  And now let's make a Table of those things with the n in 10 to the n going from 1 to let's say, yeah, let's say zero to 4, let's say so hopefully what it will do is to make a series of geographic pictures, we told it to put a disc around the Eiffel Tower with a radius to 10 to the N miles.  Come on, wake up here, and then display that, display that on a map.  
     OK, so there we go.  So that's close in, little bit further out, further out, there we go, OK, so that's kind of weird so a 10 to the 4, that's almost the whole earth.  There's only a tiny piece of earth that's not reached by that disc.  
     OK, so then we can -- I mean in the system, we know about all kinds of things.  So for example, let's say we can sort of combine all these different piece, let's say we look at the Atlantic Ocean, and let's say one of the things we might know about the Atlantic Ocean is where are their there shipwrecks in the ain't, OK?  
     So there will be a list of shipwrecks, it's kind of remarkable to me just directly in the language we could pick up something in that data, we could say geo list plot of those entities and hopefully it will load in.  Come on, wake up.  OK, if the network connected, OK.  There we go.  OK, so that's the positions of shipwrecks in the Atlantic Ocean based on data that came from the language.  Let's do something with words.  OK, so there's a list of 100,000 words in English.  Let's go ahead and say, something like -- let's just look at the lengths of those words.  So let's get those lengths.  Let's go ahead and make a histogram of those lengths, so this will tell us the distribution of lengths of words in English.  OK, that's nice.  Maybe we can go ahead and do something different.  How about we find the first letter of each word in that dictionary, OK?  
     And then let's go ahead and say -- let's make something which says, let's make a tally of all those first letters.  Actually, I tell you what, after we've gotten the first letters, let's make them up upper case.  And then let's tally up all those things.  It's telling us the number of A whatevers, A rings or whatevers and now we can say -- let's just say something like this. -- let's try this and see what happens here.  So I'm going to go ahead and take that and apply it to this list.  OK, so what this is doing.  Actually let's do it in a different way here.  Let's do divided by 100 for example here, and OK so what that's doing now is making each letter in the size that corresponds to the number of times that letter occurs as a first letter in English in this case.  
     OK, just for fun we can try and do it, I don't know, let's try and do it for let's say Russian for example.  OK, then we should get see what happens here.  Hopefully it can load in a Russian dictionary.  Wake up.  No, terrible.  Well, all right.  That's odd.  OK, let's put it out of its misery.  I don't know why that didn't work.  I'm surprised that didn't work.  I think maybe it's time for me to look at the documentation and know whether I actually did this right.  I think I did.  OK, let's see.  For some reason it's refusing to do that.  Who knows.  OK.       So anyway, there are lots of kinds of things that we can do with data.  One of the things that we can also sort of -- one of the things that we curate is data formats, as well as APIs, as well as actual ordinary data we're also interested in curating data formats and curating APIs for looking at data.  But let's just say we go and let's pick up some data from the world, so to speak.  Let's say we get data from a UN website, for example.  That's some plain text scraped from the front of the US website and now we can go and say we split that into on every new line and now let's say, now one of the things that we have, and remember, one of the goals of the Wolfram language is to automate as much as possible.  One of the things that we've done is put in all of the state of the art learning stuff to try to make it as automated as possible so you don't have to know the details of the machine learning, in this particular case you were using a built in classifier for human languages and that's telling us what language each of these phrases was in.  Looks reasonably good there.  
     Let's try doing something a little bit ambitious.  Let's see if we can build a classifier for something, OK?  So let's try to build a classifier for paintings, OK?  OK, there's Vincent Van Gogh.  And let's say, notable artworks there.  And let's -- this should give us a list of notable Vincent Van Gogh artworks, there we go.  Let's call this VG for Van Gogh, and OK?  And now I'm going to let's say -- bad variable manners, but anyway, never mind.  Let's have Picasso, and let's take some of his notable artworks.  And let's go ahead like that.  OK, so now let's get -- let's say, let's take I don't know, let's take, I don't know, 20 notable artworks from Picasso and let's get images from those so we go ahead and ask for this.  
     OK, so let's get those, and then what we're going to do so the goal of what we're doing, OK, so there's 20 random artworks from Picasso.  So let's go ahead and take the corresponding thing from Mr. Van Gogh, and let's do the same thing there.  And code it avg for that.  This is terrible, I shouldn't be doing this in, I should be doing this in a much more organized way, but anyway, so let's take this so we've got our list of Van Gogh things, so let's say those are -- so let's say the Van Gogh ones are -- let's say all of those are -- let's just put in, let's put in Van Gogh as an entity here.  OK?  
     And now we're going to take, so now we're going to do this, we're going to thread those, so we've got a list of painting and Van Gogh and we take the same thing for whatever it was, Picasso, that was line 20, bad programming practices, but still, OK, so now let's put in that for Picasso, OK, and now let's then flatten that out.  So what we should have is a bunch of -- this is sort of our training dataset, right?  Bunch of paintings by Van Gogh, a bunch of paintings by Picasso, and what should should get out is a classifier function that's using random forests.  This is a function that we can now take and apply to a random picture.  So for example, let's take another somewhere here, let's take one we hadn't got, so let's take whatever that one is.  So let's take that image there, that picture, let's see what that picture is, OK, so we are a just going to take out the image for this, and oop, oh, dear, oh, well.   
     OK, sorry about that.  Well, let's try another one.  That can happen.  Try another one of these, otherwise we'll just try a random one.  Let's try ... come on ... let's get the image here.  Network, come on.  There we go.  OK.  We got an image.  Great, OK, so now what we want to do is take the classifier function that was there and apply it to this particular thing and we didn't have a large training set so I have no idea whether this is actually going to work so let's give it a try and it said Picasso.  Which is presumably wrong.  Is it wrong or is it right?     
     You know what, it was right.  OK.  So OK, so some sort of indication of the kinds of things that are in the Wolfram language and as I was mentioning this sort of a very broad collection of kinds of knowledge and algorithms and so on that are part of the language, big system, sort of the goal that I've had is to sort of think about all the kinds of computations that people might want to do, all the kinds of knowledge that people want to work with, and to try to sort of organize all of that sort of computational work into these kind of repeated lumps which we can then give names to in the language and then implement as efficiently as possible the and it's sort of been interesting in terms of the implementation of algorithms, the more we build in the language and the more that we set up so that every different piece can interpret, the more that we're able to build more powerful algorithms, because it's a typical thing, you're building an algorithm and you think it's about geometry, but it turns out that needs to make use ever algebraic computation inside the system and because all of those pieces are all part of the language it becomes easy to build your new algorithm on top of those giant building blocks that have been created before.  
     Well, we can do -- there's -- one of the questions is sort of how does all of this work?  So this is a symbolic language.  So you type in X.  It just says it's X just like you can type in Van Gogh and it's Van Gogh.  And you can did symbolic things and we can treat that as a mathematic symbolic variable, but also, any kind of construct in the language is represented in this kind of very uniform way as a symbolic expression which is effectively pa tree kind of a structure and there are various kinds of operations you can do.  
     A very common thing you can do is say nest list and that would give us successively nested versions of this and let's say the function that we used here was framed or something, then we get successively versions of that.  Or we go nest list of edge detect of our current image, 10 times or something, and oh, come on, let's do it again.  And that will -- you know, all of these kind of things can be done, you know, so nest list is sort of a generic function that works on any kind of a pure function.  Notice that this notion of pure functions is used a lot in the system, so for example when I built that classifier what came back was a pure function.  
     If I wanted to say, for example, let's take, I don't know, we could take those images if we wanted to that we just got and we could make a function that gives us -- that is a function, which applied to an image will tell us what image it is nearest to, OK?  So I apply it to that image, it will tell us it wasn't very exciting because it will tell us the nearest image is that image itself.  But the whole point is this is a function that can come back and one sorts of builds up the whole tree of these sort of things.  So one feature of the system is everything is symbolic, you know, when you type in some expression like this, you know, that's symbolic.  So you can see what's the tree form it looks like this.  
     So for example if we make a 3D graphic that's just a symbolic expression which happens to render as a 3D graphic that moves around or for example this whole document that we're working in, this is also a symbolic expression.  I could add a section heading to this document and so on, all of this is also a symbolic expression.  So for example, we can do things like let's imagine that we make a -- we can make a template document so we could say something like we could say you know the heading and we could put in a expression here which is the date string which is the current date and we could say more info and put something in which is an expression that corresponds to the current location, so this now becomes a template for a report.  If I wanted to with this simple input I could say generate that report and now I will get back this thing here.  
     What's happening underneath is that all these things are just symbolic expressions and it's just applying the same symbolic expression processing mechanism to all of them.  So whether this was a string or a document or a piece of XML or whatever, it can apply the same symbolic expressions to.
     The question is what do you do with job symbolic expressions.  One of the things is that this notion of patterns, so when I define a function, I say, F of X blank:  Equals, I don't know, x of F.  Actually forget that.  Let's just say f of 11 equal to 1, OK?  So now I say what's F of 1, it says 2.  If I say what's F of 2, it says it's F of 2.  I don't know what F of 2 is yes.  But if I say 20 or something, it will duly tell us it's a factorial.  What turns out to be very convenient is you can all of these patterns work all over the place.  So for example, I could define a function F which when it sees G of x blank and X blank here, then it will transform it into H of you know, x or something like this and now whenever I type in F of G of 6, 6 and then let me put something else in here, I can say F of G of 7, 8, then what will happen is it will transform the first one, but not the second one.  This is a very general mechanism.  This is how the whole system works, it's just these transformation rules for symbolic expressions and this is the way the system has worked for 26 years, and it's sort of a very powerful way of doing things and very general way of doing things and sort of everything gets represented in terms of symbolic expressions in this way.
     Well, so another thing that we sort of realized recently is that we can also represent not only the operation of the language, but also the deployment of the language in terms of symbolic expressions so let me show you how that works.  So let's imagine we're going to deploy something to the web.  Let's say we're going to create a form.  This seems to be my favorite ones these days, cats I believe are popular on the internet so we'll make a form that does something with -- let's do this.  Let's make a form that will make an image of a cat breed.  OK?  So let's make it nice and big.  
     OK, so what this is, this is a form function, it's a field with a name breed, and that field is going to be a cat breed and now what we can say is deploy this to the cloud.  So take that form function and deploy it to the cloud, now we'll get back this cloud object represented by UUID.  We go to the web and it tells me to sign in.  OK.  
     And I could have said make that a public form, but OK, so now I go and this is now a form that was created, we're using our natural language understanding stack, so this field is kind of a smart field that understands natural language and is expecting a cat breed there and now if we go and run it we'll get a picture of a cat breed.  Now let's go and change this a little bit.  Let's say we want to also add -- rotates the cat by some angle, OK?  
     So let's say that's probably going to be a number and let's put in something here that says rotate that by angle -- no we don't want to rotate by the name of the breed.  Let's do that. -- OK, so now we'll we should get a field with two forms, a form with two fields so let's say we got a Siamese cat here and this is a smart field that says it's expecting any kind of cat, and oops, that angle was in radons, so now we have a rotated cat.  OK.  So you say.  What's going on is I just deployed this symbolic form to the web and it's just a form on the web when you submit the form it goes and runs the Wolfram language code in the cloud and returns the result to the web.  Now, I can also take this thing and instead of making it a form, I could create an API from it and now cloud the API function on its own is just a symbolic object but I can say cloud deploy the API function and if I go to that API, I didn't give it any parameters so it will just give me an error, but to figure out how I could move in this field, I could go here.  So I can say, you know, breed equals Siamese, so, angle equals four or something, and now, now it will use that as a RESTful API and call that same piece of code and get back the results.  
     And you can obviously get the output as JSON or anything else.  You can also take the symbolic API function and, you know, there's just a pure symbolic API function, we can take that and we can say give me embed code for that let's say an external jobber program.  So it will generate code which allows one to call that --
>>
[applause]
     So in the case of java, there isn't a cat breed data type.  OK.  So this is a whole sort of a whole stack of technology here.  You can get access to all the knowledge that's in the Wolfram language and all the computation and Analytics and so on from APIs that you create that go inside, that can be put inside other languages.  You can also immediately create mobile apps, in fact, these forms can be immediately used in mobile apps, well, there's one in ILS that's about to come out, that you'll actually be able to directly create APK files for android that simply implement a little app based on the Wolfram language code that you have.  And the stack has many different pieces.  This particular piece of code will call our public Wolfram cloud.  You can also have a private cloud and you can also not call it a cloud but you can have a version of the Wolfram engine that's working on a local network, you can even have a library version so you can actually link into the program that you're calling it from and all of that happens in a transparent kind of way using this kind of embed code mechanism calling the Wolfram language, and sort of our goal is to have the language just run on in all possible environments and be deployable as universally as possible and we're sort of steadily moving towards that.  
     You can also do things in terms of we support lots of parallelism and so on, and so, for example, let's do something really boring here, let's say I make a table of 30 process IDs and this is just going to run locally on my machine.  You'll probably see for a moment it will start up the kernels on different cores.  And it will give us the results.  It distributed that not very exciting computation of finding the process ID across those different things.  If we ask us accounts there, it will show us us, OK, two of the cores got 8 instances running and two of them got 7.  There's a much more general mechanism of doing this across networks and we're building a whole bunch of things for discovering processes out there.  One.  Well, another thing that we've been doing is trying to connect all of this to all sorts of devices.  One of the things that we have is we sort of inventoried lots of kinds of devices that exist in the world.  
     This is sort of another curation effort like so many others and we've been sort of steadily working through.  So here's about 3700 different kinds of devices that measure all kinds of things and you can get all the data for these devices in Wolfram/Alpha and so on.  One of the things that we'll be coming out with soon is a thing that we call our data drop and that's a mechanism, see if I can show you, that's a mechanism for -- there we go.  Don't know if it's going to work very well.  It's a mechanism for accumulating data into the language from sort of anything.  Web MPI, email, tweets or anything, and being able to conveniently from within the language pull up a data drop and treat it as just another piece of data that can be operated on, and obviously we have ways of operating on time series and things like that, so it all becomes rather convenient.  I should say that one of the nice ways of doing this, the Wolfram language is bundled with a Raspberry Pi computer.  
     Then use this data drop mechanism to send data into the cloud from any instance of the Wolfram language and a whole stack of things including Wolfram language and so on that rely on the language.  OK, so one question is OK if you're going to use all this stuff how can you actually develop things with it?  Well, what we've been doing, this language in the form that I'm showing you is very new and we're just starting to release actual sort of products that make use of the language, so for example, one of the things that we brought out a couple of months ago now in beta form at least is what we call the programming cloud and the idea of the programming cloud is that -- let's see.  Hopefully I'm logged in.  The programming cloud you can use it directly in a web browser, so here I'm just going to get the exact same environment that I had -- wow, that's small.  OK.  Let me see.  There is got to be a way to make this bigger.  There has got to be a way.  This is supposed to be a beautifully responsive design.
[laughter]
    Well, OK, well, here I tell you what.  Maybe I can cheat.  No, that's weird.  Well, who knows, let's see if we can do anything here.  Wow, let's just see, OK, we can do something here.  All right.  Let's -- it's kind of a -- it's kind of difficult to get to replicate the whole sort of user interface experience that we've built over the last 20-something years, in the native environments within a web browser, but we've got quite a long way in doing that.  But what's important about the programming cloud is you can develop your code, you can develop it either in this web environment or you can develop it on the desktop and then you get to deploy it into your cloud and create all those instant APIs and instant forms and so on or scheduled tasks or whatever else.  So that's one thing that we're building based on the Wolfram language.  Another thing that we're building is a data science platform where kind of the idea is there's a flow from data, sos and we have many data sources that we can bring in an then out to reports that you generate.  And it's pretty neat being able to settle that up so quickly and have something where you can either schedule a report to send a PDF every Monday morning, or you can set it up as an instant API that is then called from some device or some mobile app or whatever else.  So that's another thing that's coming.  So another thing we found interesting about our language is that I think the -- that we sort of realized -- I've been thinking about it for a long time, but people really pointed this out when you started showing videos about what the language could do.  
     This is a great language for people to learn programming in.  Because you could immediately start to do things that relate to the real world and you can get a lot done with very simple pieces of code and in fact it's sort of interesting to see how should people learn this language?  I think it's very much more like learning a human language than perhaps.  I think immersion language learning seems to be the right approach where you can just say OK, just look at some code that works and and try and understand from looking code that works and then go and read that 15-page introduction for the language that tells you the principles and tells you about pure functions and tells you about pattern matching and things like that.  
     Often you've seen a program that works.  We're building a thing called program lab which is intended for anybody who wants to learn to program and the idea is that we just show some code here, and then we say OK, you can do this yourself, and if this wasn't so big, let me see if I can make this the right size, -- OK, so you know, it just says go ahead and I don't even know what this is supposed to be but I should have actually read the text.  I don't know what I'm doing here.  Add the types to the mandrel, and OK we've got a striped mandrel.  But the point is you have some objective and you're trying to produce these quite short programs that do something interesting and this seems like a very attractive way for people to start learning to program.  OK, well, so one of the features of this is that -- one of the features of this language is because it has so much built in, it means that a piece of code that does something quite nontrivial can be really short and so this is a neat feature and I thought how can we show off this neat feature and so I had this idea recently.  What's a place where really short things show up?  Well, Twitter, so why we don't about having tweetable programs.  And then has the system respond to it?  
     Well, as of about an hour ago, a little less than an hour ago, there should be a thing up on the web.  Let's see if this is really true.  There is a thing that is called -- let's see.  Wolf ram tweet a program.  Let's see if it's really there.  Oh, there we go.  Oh, gosh.  OK, so what this is is something where you send in a tweet, and it will, OK, these are random things people have been tweeting in so let's look at that one.  OK, so this is -- OK, so these are random programs, little programs that people have been tweeting in that generate output.  So we can take a look just for fun I'll show you a few examples that I've made of what might call tweetable programs.  It's kind of remarkable that you can make anything nontrivial in the space of a tweet.  But let's see what we can do.  
     For example, well, one -- let's see, here's one.  So we can take -- so this is a sort of a simple -- the obvious simple hello world example.  Interpreted for modern times.  And you know, we can do all sorts of things, like you know, it's almost, I think it's like code poetry in some sense.  Here's a very simple piece of code.  That's what it does and if you look at the piece of code, you kind of think about it a little bit.  You'll have an aha moment of OK, it's a table of things and it's making tuples out of those.  It's interesting, because humans can read this code and computers can read this code and do something with it.  
     And I was trying to figure out what's the shortest program that does something interesting and so here's kind of a ridiculous little hack that makes a Sierpinski in how many characters?  This is a very modest number of characters here.  36 characters, not too bad, and you can do things like let's say -- oh, I don't know, let's look at -- you know, we can do all kinds of things.  I don't know, here's a -- see what this is.  This I think just fits in a tweet that will make a random collection of polyhedra in 3D space, which I think isn't bad for something -- oh, great.  That's -- anyway, so all kinds of things like this.  I've been trying to figure out what's the sort of shortest program that does something interesting?  
     Actually, I have to say I spent some decent part of my life studying very small programs because I've been interested in sort of understanding to what extent one can make a science of the computational universe of possible simple programs and way back when, well, I started studying these systems called cellular automata, which are simple programs with black and white cells and I had this experiment more than 30 years ago that led to this whole new kind of science that I made and it's kind of fun that as of today, that experiment is now tweetable.  
     So that's the complete code that does that experiment and shows us and generates all these pictures that show the result of running simple different programs.  So that would be -- what on earth did that do?  That is the strangest thing.  I think this is what I get for running at incredibly low resolution here, all right so actually one of the things that's interesting is these are tiny little programs, and the question is, what do these programs do, and sometimes these programs do just really trivial kinds of things, but sometimes they do really quite complicated things, so there's an example of my all-time favorite very simple program that does something complicated it's called Rule 30.  It's a cellular automaton.  It starts off in one black cell at the top there and it makes that very complicated pattern.  What's interesting about this is it's a program that's sort of just out there in in computational universe and when we do programming we try and engineer things, we try and figure out how am I going to incrementally build a program that does what I want.  An alternative is to go out and mine programs that do something interesting.  
     So this Rule 30 is an interesting one to mine.  If you look at the central column it's been for the last 25 years the only sort of surviving random sequence generator that hasn't been cracked in some way or another.  We used it for a long time in our technology.  We actually recently retired it because we did a huge search in the computational universe and we found a cellular automaton that's a little more efficient at generating cellular data than this.  It's not engineered by humans, it's found and we train it and use it for our technology.  And this is an approach to programming that I think will be increasingly of interest.  It's something that he have we have used for many years now of just going out into the computational universe and searching trillions of programs to find ones that do something useful for us.  And then just use those in our programs.  Well, one of the questions if you're interested in science, one of the things that I spent a lot of time studying is to what extent these simple programs can represent models of the northerly world and so on and to what extent you can use, you know, people have traditionally used equations and things to model the natural world.  Sort of the ultimate question, then is well, what about the whole universe?  Is it possible we can model the whole universe in terms of some simple program that can be specified and then will just run and repo space and all the things that are in the universe so the if the universe corresponds to a simple program, is that program short enough that it's actually a tweetable program and so the question then becomes, you know, is the universe ultimately tweetable.  So that's my question for the day.  I don't know the answer.  I'm hoping one of these years to be able to do the physics so to speak, to figure that out.  But one thing that sort of coming back to practicality, you know, we've tried to build the Wolfram language to sort of automate as much as possible to build in as much as we can.  How long the code for the universe will be in the Wolfram language we don't yet know, but the code for lots of things is remarkably short and easy to write and I think one of the things that's interesting is I think with this new kind of programming language, one's able tock from sort of ideas, algorithmic ideas to actual running code and actual deployed products in sort of the shortest path that we've ever seen and so I'm excited to see what people will do with this new ability to program, sort of new direction in programming and now we are starting to have these tools and products and so on that let people actually take the idea of this language and use it to actually build products and such like.
>> so I think that's probably everything I had to say.  I hope we have time for questions and things.  I've probably gone way over time, I don't know.  But --
[applause].
>> thanks.
>> Two minutes?  I'm sorry, I -- that's what I get for not having a clock.  Excuse me, yes, please.  
AUDIENCE MEMBER:  [inaudible]
>> Well, the primary mechanism is creating instant APIs and using embed codes to be able to call those APIs, that's the easiest to deploy mechanism.  We have this thing it used to be called math link that allows us you to really exchange symbolic expressions and things between programs.  That's something that's been built out for C and java and a bunch much other languages and allows compatibility to the Wolfram language and other languages.
>>
>> 
AUDIENCE MEMBER:  [inaudible]
>> yeah, OK, so the question was about contributions into the language.  You know, we've had for Mathematica we've had a very successful website called the demonstrations project and it has about 10,000 -- there are about 10,000 interactive demonstrations that people have created here.  And what's interesting about these, they're kind of open code things and because the code is very short and readable, people regularly take code from here and use it for other purposes.  In terms of the ability to sort of have a marketplace mechanism for little lumps of orphan language code, that's something that we intend to build, it isn't built yet, it should be rather straightforward.  I mean what we've tried to do is make sort of a consistent language that has in our case 5,000 built-in functions and some number of tens of millions of sort of built-in entities and things like that and we've tried to make the effort to make sort of all of that consistent and it's been a lot of work, but you know, on top of that, people can build all sorts of interesting things and people in the Mathematica sort of precursor of this, people have been building all kinds of things for a quarter of a century that are based on that system.  I think it will be a more effective ecosystem for the Wolfram language and we have some nice modern mechanisms, I think for dealing with it.  Maybe one more if we can.  Yes, please?
AUDIENCE MEMBER:  [inaudible]
>> Yeah, I've tried to write, you know, write a blog occasionally and I've tried to write a few things about design.  You know, it's a complicated story.  It's really you know this is what I've been doing for 35 years, language design and there's a lot to say about it.  I mean I think that -- it's interesting to me that my view of language design has evolved somewhat over the years.  And so you know, for instance, one thing that's really critical is things like the naming of functions, right?  And it takes forever to name these things, because if you get -- if the name is too specific people don't understand the generality of its use, if it's too general, people don't know what it is.  And an example of something that's evolved in the last decade for me, OK when I was first building languages, I thought that if there was something which could be done as a simple idiom in the language, just let people do it with that simple idiom.  If it can be done in two functions or something, just leave them with that idiom.  I realize that's wrong.  If that idiom has a well defined name, you might as well have a function that corresponds to that idiom.  Because when people see the code, they know now I understand what it is.  If it doesn't have a reasonable function, you shouldn't make up a name for it because it won't help anybody.  It's easy for us to process programs like data and so we can do all kinds of interesting sort of symbolic refactoring of programs and so on and we can do program simplification, and we can do all sorts of things to help people write good code.  One of my theories about programming language is if you have a well designed programming language and you have some operation you're trying to do and there are sort of various variants of that operation that you might do, the one that corresponds to the shortest piece of code is the one that is likely to be correct.  And what you find as a result of simplifying the code is mostly there's a simple code but there are those weird "if" conditions off the end.  Those weird "if" conditions are probably bugs.  I don't really know how to communicate, within our company, for example, it's been when you design 5,000 functions, you know, you -- I didn't do all of that myself so to speak and it took me a long time to train people to understand sort of design methodology for understanding how things work.  I'll say one other thing about design.  For me one of the things that's most interesting about design is it is the best way to force you to really, really understand an area is to try and design functionality around that area and I realize every time I try and sort of cut corners and not really, really understand at the very fundamental level what's going on in some particular area, that's the time when I'm likely to make a design mistakes.  Because you start off with all this complicated functionality and there's 100 things you might want to do and it's going to turn into 200 different functions and they're all very complicated and there's no framework between them.  Sometimes it's taken me, a decade, tup decades, sometimes to understand what the unifying principles are.  Example:  We just introduced a large geometry function.  It took a long time to see how to do that.
     Another thing I might mention is two more things about design.  Just -- I could go on about design for ages and I'll shut up in a moment, but the two more things, the one thing is that this kind of symbolic paradigm that I originally started working on in the first language I designed which was I think called SMP, which was a precursor of Mathematica.  SMN was a language I designed starting in 1979 and the language turned into a product that turned into a company, etc., etc., etc. but it was a language which in many ways was much more bizarre and extreme than what I've designed in what's now the Wolfram language and I made many stupid mistakes in a language for example that was a time when people couldn't type very well and having short command names was relevant which is completely irrelevant and silly.  I tried to be much more fascist and I said that's the only thing you're going to want to do.  If you want to do procedural programming, forget it, that was a mistake.  When you design a language, whatever your theory of things has to be the language is ultimately for humans and humans have a certain set of experiences and they have a certain sort of knowledge base and you have to cater to that knowledge base.  
     One of the things that's been interesting recently is because over the course of decades, the ambient understanding of things changes it allows you to put constructs into the language that you couldn't have put in 20 years ago because people didn't have a general understanding of that and people would say what is this?  But anyway, the thing that has happened is when I first was designing this -- -- I've been interested ant sort of tried to make the general symbolic system and what I realized is OK, I thought this is a good idea and then started to build Mathematica, and it's just you know we realize we can represent documents, we can represent graphics.  We can represent deployment mechanisms, we can represent process, we can represent all these different kinds of things and every few years realize we represent another kind of thing in the same framework.  One last thing about design, OK?  
     I've had one of the things that was very useful for me, so in designing Mathematica and the Wolfram language that's a very precise design activity.  It's something where you're trying to make a very perfect design you're trying to make this thing where you can build these bricks and go on and build them forever and you're worried about all the precedents.  What are the precedents for the language in this thing and is this something that is going to fit in with everything else we've built before and there's a whole scholarship associated with that that we do.  OK, so then I started working on Wolfram/Alpha and the question was would I design Wolfram/Alpha the same kind of way as the Wolfram language and I said no, let's go to the exact opposite extreme.  In Wolfram/Alpha I want it do what I mean, I wanted full of heuristics.  I had thought previously. -- you type something in, it's going to do what people think it should do, OK?  What I learn is that when you have a big enough tower of heuristics, they have a kind of logic all their 0 own and in fact in Wolfram/Alpha it is a good system.  Millions of people use it every day.  There's no manual.  People just go up to it and they start typing things into it and it works about 97% of the time it understands what they said.  So what was interesting to me was this completely different design methodology of just have it be heuristics all the way down and in Wolfram/Alpha we were trying to represent the whole world and the question was should we start off with a grand theory of the world.  So there's a certain tendency to say let's use the grand theory of the world.  And I said let's do the opposite of that.  As we see what we've built build bigger and billing bigger frameworks that many connect those together.  
     So then I realized a few years ago that I can kind of combine them to make something which is now the Wolfram language where we're sort of combining two different methodologies, the sort of natural language do what I mean kind of methodology and the precise methodology.  There you're dealing with real world entities, it would be hopeless if you had to have a manual that said, New York City is represented in the system as the canonical name given in the US gazetteer for whatever else it is, but you just want to type the name and that's what you can do because you've combined the natural language thing.  OK, I can go on yak about language forever and I should probably stop.  Thank you very much.  
     ALEX:  Thanks so much.  That was amazing, and we'll be back here tomorrow morning, and the unsessions are tonight, 7 to 10.  Thank you everyone ... ...
[break] 
